{"case_id": "VCFCST-1.1.1-001", "vcfcst_category": {"level1": "需求意图与拆解失效", "level2": "需求意图理解失效", "level3_id": "1.1.1", "level3_name": "核心需求遗漏", "defect_desc": "遗漏业务场景中默认必须满足的核心隐性需求"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个用户注册功能，要求：1. 用户名长度在3-20个字符之间；2. 密码必须包含至少一个大写字母、一个小写字母和一个数字；3. 注册成功后返回用户ID。", "initial_code": {"src/user_service.py": "class UserService:\n    def register(self, username: str, password: str) -> dict:\n        \"\"\"\n        用户注册\n        :param username: 用户名\n        :param password: 密码\n        :return: 包含用户ID的字典，如 {'user_id': 123}\n        \"\"\"\n        # TODO: 实现注册逻辑\n        pass\n\n    def _validate_username(self, username: str) -> bool:\n        \"\"\"验证用户名格式\"\"\"\n        return 3 <= len(username) <= 20\n\n    def _validate_password(self, password: str) -> bool:\n        \"\"\"验证密码格式\"\"\"\n        has_upper = any(c.isupper() for c in password)\n        has_lower = any(c.islower() for c in password)\n        has_digit = any(c.isdigit() for c in password)\n        return has_upper and has_lower and has_digit"}, "acceptance_criteria": {"test_code": {"tests/test_user_service.py": "import pytest\nfrom src.user_service import UserService\n\nclass TestUserService:\n    def setup_method(self):\n        self.service = UserService()\n    \n    def test_valid_registration(self):\n        \"\"\"测试有效注册\"\"\"\n        result = self.service.register('testuser', 'Pass123')\n        assert 'user_id' in result\n        assert isinstance(result['user_id'], int)\n    \n    def test_username_too_short(self):\n        \"\"\"测试用户名过短\"\"\"\n        result = self.service.register('ab', 'Pass123')\n        assert result is None\n    \n    def test_username_too_long(self):\n        \"\"\"测试用户名过长\"\"\"\n        result = self.service.register('a' * 21, 'Pass123')\n        assert result is None\n    \n    def test_password_no_uppercase(self):\n        \"\"\"测试密码无大写字母\"\"\"\n        result = self.service.register('testuser', 'pass123')\n        assert result is None\n    \n    def test_password_no_lowercase(self):\n        \"\"\"测试密码无小写字母\"\"\"\n        result = self.service.register('testuser', 'PASS123')\n        assert result is None\n    \n    def test_password_no_digit(self):\n        \"\"\"测试密码无数字\"\"\"\n        result = self.service.register('testuser', 'Password')\n        assert result is None\n    \n    def test_duplicate_username(self):\n        \"\"\"测试用户名重复\"\"\"\n        # 第一次注册应该成功\n        result1 = self.service.register('uniqueuser', 'Pass123')\n        assert 'user_id' in result1\n        \n        # 第二次相同用户名应该失败\n        result2 = self.service.register('uniqueuser', 'Pass123')\n        assert result2 is None\n    \n    def test_special_characters_username(self):\n        \"\"\"测试特殊字符用户名\"\"\"\n        result = self.service.register('user@name', 'Pass123')\n        assert result is None"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者可能只实现显式需求（用户名长度、密码复杂度），但遗漏了业务场景中默认必须满足的核心隐性需求：用户名唯一性检查。在真实的用户注册场景中，防止重复用户名是必须的，但需求描述中没有明确提及。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-1.1.2-001", "vcfcst_category": {"level1": "需求意图与拆解失效", "level2": "需求意图理解失效", "level3_id": "1.1.2", "level3_name": "需求语义误解", "defect_desc": "错误解读行业术语或业务规则，导致实现偏离真实语义"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个函数，计算电商订单的'满减优惠'。规则如下：订单总金额满100元减10元，满200元减30元，满500元减100元。优惠不可叠加，仅适用最高档位。", "initial_code": {"src/order_calculator.py": "def calculate_discount(total_amount: float) -> float:\n    \"\"\"\n    计算订单满减优惠金额\n    \n    Args:\n        total_amount: 订单总金额\n        \n    Returns:\n        优惠金额\n    \"\"\"\n    # TODO: 实现满减优惠计算逻辑\n    return 0.0\n\ndef final_amount(total_amount: float) -> float:\n    \"\"\"\n    计算订单最终支付金额\n    \n    Args:\n        total_amount: 订单总金额\n        \n    Returns:\n        最终支付金额\n    \"\"\"\n    discount = calculate_discount(total_amount)\n    return total_amount - discount"}, "acceptance_criteria": {"test_code": {"tests/test_order_calculator.py": "import pytest\nfrom src.order_calculator import calculate_discount, final_amount\n\nclass TestOrderCalculator:\n    def test_calculate_discount_edge_cases(self):\n        \"\"\"测试边界条件\"\"\"\n        # 刚好达到满减门槛\n        assert calculate_discount(100.0) == 10.0\n        assert calculate_discount(200.0) == 30.0\n        assert calculate_discount(500.0) == 100.0\n        \n        # 未达到最低门槛\n        assert calculate_discount(99.99) == 0.0\n        assert calculate_discount(50.0) == 0.0\n        assert calculate_discount(0.0) == 0.0\n        \n    def test_calculate_discount_mid_range(self):\n        \"\"\"测试中间范围\"\"\"\n        # 100-200之间\n        assert calculate_discount(150.0) == 10.0\n        assert calculate_discount(199.99) == 10.0\n        \n        # 200-500之间\n        assert calculate_discount(300.0) == 30.0\n        assert calculate_discount(499.99) == 30.0\n        \n        # 超过500\n        assert calculate_discount(600.0) == 100.0\n        assert calculate_discount(1000.0) == 100.0\n        \n    def test_final_amount_calculation(self):\n        \"\"\"测试最终金额计算\"\"\"\n        assert final_amount(100.0) == 90.0\n        assert final_amount(200.0) == 170.0\n        assert final_amount(500.0) == 400.0\n        assert final_amount(150.0) == 140.0\n        assert final_amount(99.99) == 99.99\n        \n    def test_negative_amount(self):\n        \"\"\"测试异常输入\"\"\"\n        with pytest.raises(ValueError):\n            calculate_discount(-10.0)\n        with pytest.raises(ValueError):\n            final_amount(-10.0)"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者可能误解'满减优惠'的行业语义，错误实现为：1) 将优惠理解为'每满'而不是'单次最高档位'，实现为阶梯叠加计算；2) 误解'满'的含义，错误处理边界条件（如认为100元'不满'100元）；3) 错误理解'不可叠加'，可能实现为多个优惠组合而非取最高档。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-1.1.3-001", "vcfcst_category": {"level1": "需求意图与拆解失效", "level2": "需求意图理解失效", "level3_id": "1.1.3", "level3_name": "约束条件忽略", "defect_desc": "忽略技术/环境/兼容性等硬性约束"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个图片格式转换工具，能够将用户上传的图片转换为PNG格式。用户上传的图片可能是JPG、BMP或WebP格式。转换后的图片需要保持原始图片的宽高比，并且文件大小不能超过500KB。", "initial_code": {"converter/image_converter.py": "from PIL import Image\nimport io\n\ndef convert_to_png(image_data: bytes) -> bytes:\n    \"\"\"\n    将图片数据转换为PNG格式\n    \n    Args:\n        image_data: 原始图片的二进制数据\n        \n    Returns:\n        PNG格式的图片二进制数据\n    \"\"\"\n    # TODO: 实现图片格式转换功能\n    # 要求：\n    # 1. 支持JPG、BMP、WebP格式输入\n    # 2. 输出PNG格式\n    # 3. 保持原始宽高比\n    # 4. 文件大小不超过500KB\n    \n    # 临时返回空数据，需要实现完整功能\n    return b''"}, "acceptance_criteria": {"test_code": {"tests/test_image_converter.py": "import pytest\nfrom converter.image_converter import convert_to_png\nimport os\n\n# 测试数据准备\ndef create_test_image(format='JPEG', size=(800, 600)):\n    \"\"\"创建测试图片\"\"\"\n    from PIL import Image\n    import io\n    \n    img = Image.new('RGB', size, color='red')\n    img_byte_arr = io.BytesIO()\n    img.save(img_byte_arr, format=format)\n    return img_byte_arr.getvalue()\n\nclass TestImageConverter:\n    def test_jpg_to_png(self):\n        \"\"\"测试JPG转PNG\"\"\"\n        jpg_data = create_test_image('JPEG')\n        png_data = convert_to_png(jpg_data)\n        \n        # 验证返回数据不为空\n        assert len(png_data) > 0\n        \n        # 验证文件大小约束（硬性约束）\n        assert len(png_data) <= 500 * 1024, \"PNG文件大小超过500KB限制\"\n        \n        # 验证格式确实是PNG\n        from PIL import Image\n        import io\n        img = Image.open(io.BytesIO(png_data))\n        assert img.format == 'PNG'\n    \n    def test_bmp_to_png(self):\n        \"\"\"测试BMP转PNG\"\"\"\n        bmp_data = create_test_image('BMP')\n        png_data = convert_to_png(bmp_data)\n        \n        assert len(png_data) > 0\n        assert len(png_data) <= 500 * 1024, \"PNG文件大小超过500KB限制\"\n        \n        from PIL import Image\n        import io\n        img = Image.open(io.BytesIO(png_data))\n        assert img.format == 'PNG'\n    \n    def test_webp_to_png(self):\n        \"\"\"测试WebP转PNG\"\"\"\n        webp_data = create_test_image('WEBP')\n        png_data = convert_to_png(webp_data)\n        \n        assert len(png_data) > 0\n        assert len(png_data) <= 500 * 1024, \"PNG文件大小超过500KB限制\"\n        \n        from PIL import Image\n        import io\n        img = Image.open(io.BytesIO(png_data))\n        assert img.format == 'PNG'\n    \n    def test_large_image_size_constraint(self):\n        \"\"\"测试大图片的文件大小约束\"\"\"\n        # 创建一个大尺寸图片（更容易超过500KB）\n        large_jpg = create_test_image('JPEG', size=(2000, 1500))\n        png_data = convert_to_png(large_jpg)\n        \n        # 关键测试：必须满足文件大小约束\n        assert len(png_data) <= 500 * 1024, \"大图片转换后未满足500KB大小限制\"\n        \n        from PIL import Image\n        import io\n        img = Image.open(io.BytesIO(png_data))\n        assert img.format == 'PNG'\n    \n    def test_aspect_ratio_preserved(self):\n        \"\"\"测试宽高比保持\"\"\"\n        # 创建非标准宽高比图片\n        jpg_data = create_test_image('JPEG', size=(800, 400))\n        png_data = convert_to_png(jpg_data)\n        \n        assert len(png_data) > 0\n        assert len(png_data) <= 500 * 1024\n        \n        from PIL import Image\n        import io\n        img = Image.open(io.BytesIO(png_data))\n        assert img.format == 'PNG'\n        # 验证宽高比\n        assert img.size == (800, 400)  # 应保持原始尺寸"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者可能只关注格式转换功能本身，而忽略文件大小不超过500KB的硬性约束。在实现时可能不会对输出图片进行压缩或尺寸调整，导致大图片转换后超过大小限制。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0", "pillow==10.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-1.1.4-001", "vcfcst_category": {"level1": "需求意图与拆解失效", "level2": "需求意图理解失效", "level3_id": "1.1.4", "level3_name": "过度生成与需求溢出", "defect_desc": "超出需求边界生成多余功能与依赖"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个简单的用户信息验证器，要求：1. 验证用户名长度在3-20个字符之间；2. 验证邮箱格式是否正确（包含@和.）；3. 返回验证结果和错误信息列表。不需要存储用户信息，不需要密码验证，不需要发送验证邮件。", "initial_code": {"user_validator.py": "class UserValidator:\n    def validate(self, username: str, email: str) -> dict:\n        \"\"\"\n        验证用户名和邮箱\n        \n        返回格式:\n        {\n            \"valid\": bool,\n            \"errors\": list[str]\n        }\n        \"\"\"\n        # TODO: 实现验证逻辑\n        pass"}, "acceptance_criteria": {"test_code": {"tests/test_validator.py": "import pytest\nfrom user_validator import UserValidator\n\n\ndef test_username_length_validation():\n    validator = UserValidator()\n    \n    # 用户名太短\n    result = validator.validate(\"ab\", \"test@example.com\")\n    assert result[\"valid\"] == False\n    assert \"用户名长度必须在3-20个字符之间\" in result[\"errors\"]\n    \n    # 用户名太长\n    result = validator.validate(\"a\" * 21, \"test@example.com\")\n    assert result[\"valid\"] == False\n    assert \"用户名长度必须在3-20个字符之间\" in result[\"errors\"]\n    \n    # 用户名合法\n    result = validator.validate(\"john_doe\", \"test@example.com\")\n    assert result[\"valid\"] == True\n    assert len(result[\"errors\"]) == 0\n\n\ndef test_email_format_validation():\n    validator = UserValidator()\n    \n    # 邮箱缺少@\n    result = validator.validate(\"john_doe\", \"testexample.com\")\n    assert result[\"valid\"] == False\n    assert \"邮箱格式不正确\" in result[\"errors\"]\n    \n    # 邮箱缺少.\n    result = validator.validate(\"john_doe\", \"test@examplecom\")\n    assert result[\"valid\"] == False\n    assert \"邮箱格式不正确\" in result[\"errors\"]\n    \n    # 邮箱合法\n    result = validator.validate(\"john_doe\", \"test@example.com\")\n    assert result[\"valid\"] == True\n    assert len(result[\"errors\"]) == 0\n\n\ndef test_multiple_errors():\n    validator = UserValidator()\n    \n    # 用户名和邮箱都错误\n    result = validator.validate(\"ab\", \"invalid-email\")\n    assert result[\"valid\"] == False\n    assert len(result[\"errors\"]) == 2\n    \n    # 检查是否包含两条错误信息\n    errors = result[\"errors\"]\n    username_error = any(\"用户名长度\" in err for err in errors)\n    email_error = any(\"邮箱格式\" in err for err in errors)\n    assert username_error and email_error\n\n\ndef test_no_extra_dependencies():\n    \"\"\"检查是否引入了不必要的依赖\"\"\"\n    import user_validator\n    import inspect\n    \n    # 检查导入的模块\n    import sys\n    allowed_modules = {'builtins', 'typing', 'user_validator'}\n    \n    # 获取UserValidator类的源代码\n    source = inspect.getsource(user_validator.UserValidator.validate)\n    \n    # 检查是否包含不应有的功能关键词\n    forbidden_keywords = [\n        'password', 'Password',\n        'store', 'save', 'database', 'db',\n        'send', 'email', 'mail', 'smtp',\n        'hash', 'encrypt', 'bcrypt',\n        'session', 'cookie', 'token'\n    ]\n    \n    for keyword in forbidden_keywords:\n        assert keyword not in source, f\"不应包含'{keyword}'相关代码\"\n    \n    # 检查返回格式\n    validator = UserValidator()\n    result = validator.validate(\"test\", \"test@example.com\")\n    \n    assert isinstance(result, dict)\n    assert \"valid\" in result\n    assert \"errors\" in result\n    assert isinstance(result[\"valid\"], bool)\n    assert isinstance(result[\"errors\"], list)\n    \n    # 所有错误信息应该是字符串\n    for error in result[\"errors\"]:\n        assert isinstance(error, str)"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "模型可能会过度生成以下内容：1. 添加密码验证功能；2. 添加用户信息存储功能（如数据库操作）；3. 添加发送验证邮件的功能；4. 添加额外的依赖（如requests用于发送邮件，sqlalchemy用于数据库）；5. 添加用户类或复杂的数据结构；6. 添加登录/注册会话管理功能。这些都属于超出需求边界的多余功能。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-1.2.1-001", "vcfcst_category": {"level1": "需求意图与拆解失效", "level2": "需求拆解与路径规划失效", "level3_id": "1.2.1", "level3_name": "技术选型错误", "defect_desc": "选择不匹配需求的技术方案或架构"}, "difficulty": "Medium", "case_type": "modify", "requirement": "我需要一个简单的文件内容搜索工具，能够快速搜索指定目录下所有文本文件中是否包含某个关键词。用户会频繁搜索不同关键词，文件数量可能达到几千个，但每次搜索的关键词都比较短（1-3个单词）。请确保搜索效率能满足日常使用。", "initial_code": {"search_tool.py": "import os\nimport re\nfrom typing import List\n\nclass FileSearchTool:\n    def __init__(self, root_dir: str):\n        self.root_dir = root_dir\n    \n    def search(self, keyword: str) -> List[str]:\n        \"\"\"搜索包含关键词的文件路径\"\"\"\n        result = []\n        \n        # 遍历所有文件\n        for root, dirs, files in os.walk(self.root_dir):\n            for file in files:\n                if not file.endswith('.txt'):\n                    continue\n                    \n                file_path = os.path.join(root, file)\n                \n                # 读取文件内容\n                try:\n                    with open(file_path, 'r', encoding='utf-8') as f:\n                        content = f.read()\n                        \n                    # 使用正则表达式匹配关键词\n                    pattern = re.compile(r'\\b' + re.escape(keyword) + r'\\b', re.IGNORECASE)\n                    if pattern.search(content):\n                        result.append(file_path)\n                except Exception as e:\n                    print(f\"Error reading {file_path}: {e}\")\n        \n        return result\n\n# 使用示例\nif __name__ == \"__main__\":\n    tool = FileSearchTool(\"./documents\")\n    matches = tool.search(\"important\")\n    print(f\"Found in {len(matches)} files:\")\n    for match in matches:\n        print(f\"  - {match}\")"}, "acceptance_criteria": {"test_code": {"tests/test_search.py": "import os\nimport tempfile\nimport shutil\nfrom search_tool import FileSearchTool\nimport time\n\ndef test_search_performance():\n    \"\"\"性能测试：验证搜索大量文件时的效率\"\"\"\n    # 创建临时目录和测试文件\n    temp_dir = tempfile.mkdtemp()\n    \n    try:\n        # 创建100个测试文件\n        for i in range(100):\n            file_path = os.path.join(temp_dir, f\"test_{i}.txt\")\n            with open(file_path, 'w', encoding='utf-8') as f:\n                # 每个文件写入约10KB内容\n                content = \"\\n\".join([f\"Line {j}: Sample content for testing\" for j in range(1000)])\n                if i == 50:\n                    content += \"\\nThis contains the TARGET keyword for search.\"\n                f.write(content)\n        \n        tool = FileSearchTool(temp_dir)\n        \n        # 测量搜索时间\n        start_time = time.time()\n        results = tool.search(\"TARGET\")\n        end_time = time.time()\n        \n        search_time = end_time - start_time\n        \n        # 断言：搜索时间应小于2秒（对于100个文件）\n        assert search_time < 2.0, f\"Search too slow: {search_time:.2f} seconds for 100 files\"\n        \n        # 断言：应找到正确文件\n        expected_file = os.path.join(temp_dir, \"test_50.txt\")\n        assert expected_file in results, f\"Expected {expected_file} in results\"\n        assert len(results) == 1, f\"Expected 1 result, got {len(results)}\"\n        \n    finally:\n        # 清理临时目录\n        shutil.rmtree(temp_dir)\n\ndef test_search_accuracy():\n    \"\"\"准确性测试：验证搜索功能正确性\"\"\"\n    temp_dir = tempfile.mkdtemp()\n    \n    try:\n        # 创建测试文件\n        files_content = [\n            (\"file1.txt\", \"This is a sample file with apple keyword.\"),\n            (\"file2.txt\", \"No keyword here.\"),\n            (\"file3.txt\", \"Apple pie recipe with apple ingredient.\"),\n            (\"file4.txt\", \"Pineapple contains apple but not as whole word.\")\n        ]\n        \n        for filename, content in files_content:\n            file_path = os.path.join(temp_dir, filename)\n            with open(file_path, 'w', encoding='utf-8') as f:\n                f.write(content)\n        \n        tool = FileSearchTool(temp_dir)\n        \n        # 测试1：搜索\"apple\"（全词匹配）\n        results = tool.search(\"apple\")\n        expected = [\n            os.path.join(temp_dir, \"file1.txt\"),\n            os.path.join(temp_dir, \"file3.txt\")\n        ]\n        assert sorted(results) == sorted(expected), f\"Expected {expected}, got {results}\"\n        \n        # 测试2：搜索不存在的关键词\n        results = tool.search(\"banana\")\n        assert len(results) == 0, f\"Expected empty results, got {results}\"\n        \n    finally:\n        shutil.rmtree(temp_dir)\n\ndef test_case_insensitive():\n    \"\"\"测试不区分大小写\"\"\"\n    temp_dir = tempfile.mkdtemp()\n    \n    try:\n        file_path = os.path.join(temp_dir, \"test.txt\")\n        with open(file_path, 'w', encoding='utf-8') as f:\n            f.write(\"This has KEYWORD in uppercase.\")\n        \n        tool = FileSearchTool(temp_dir)\n        \n        # 使用小写搜索\n        results = tool.search(\"keyword\")\n        assert len(results) == 1, f\"Expected 1 result, got {len(results)}\"\n        \n        # 使用大写搜索\n        results = tool.search(\"KEYWORD\")\n        assert len(results) == 1, f\"Expected 1 result, got {len(results)}\"\n        \n    finally:\n        shutil.rmtree(temp_dir)\n\nif __name__ == \"__main__\":\n    test_search_accuracy()\n    print(\"Accuracy test passed!\")\n    \n    test_case_insensitive()\n    print(\"Case insensitive test passed!\")\n    \n    test_search_performance()\n    print(\"Performance test passed!\")"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "初始实现使用了逐文件读取和正则表达式匹配的方式，对于几千个文件的频繁搜索场景效率低下。需求明确要求'快速搜索'和'频繁搜索不同关键词'，但当前实现每次搜索都需要读取所有文件内容，没有使用任何索引或缓存机制，导致重复搜索时性能低下。正确的技术方案应该使用倒排索引或至少缓存文件内容，避免重复的IO操作。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-1.2.2-001", "vcfcst_category": {"level1": "需求意图与拆解失效", "level2": "需求拆解与路径规划失效", "level3_id": "1.2.2", "level3_name": "实现步骤拆解错误", "defect_desc": "拆解步骤遗漏关键环节或路径错误"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个函数，接收一个字符串列表，返回一个新列表，其中每个元素是原列表中对应字符串去除首尾空格、并将连续多个空格替换为单个空格后的结果。如果原字符串为空或只包含空格，则在新列表中对应位置返回空字符串。", "initial_code": {"src/string_processor.py": "def process_strings(strings):\n    \"\"\"\n    处理字符串列表\n    \"\"\"\n    result = []\n    for s in strings:\n        # 去除首尾空格\n        s = s.strip()\n        # 替换连续空格为单个空格\n        # TODO: 这里需要正确实现连续空格的替换逻辑\n        result.append(s)\n    return result"}, "acceptance_criteria": {"test_code": {"tests/test_string_processor.py": "import pytest\nfrom src.string_processor import process_strings\n\ndef test_basic_processing():\n    input_list = [\"  hello  world  \", \"test    string\", \"   \", \"\"]\n    expected = [\"hello world\", \"test string\", \"\", \"\"]\n    assert process_strings(input_list) == expected\n\ndef test_no_spaces():\n    input_list = [\"hello\", \"world\", \"test\"]\n    expected = [\"hello\", \"world\", \"test\"]\n    assert process_strings(input_list) == expected\n\ndef test_multiple_spaces_in_middle():\n    input_list = [\"hello    world\", \"a   b   c\"]\n    expected = [\"hello world\", \"a b c\"]\n    assert process_strings(input_list) == expected\n\ndef test_mixed_whitespace():\n    input_list = [\"  hello\\tworld  \", \"test\\nstring  \"]\n    expected = [\"hello\\tworld\", \"test\\nstring\"]\n    assert process_strings(input_list) == expected\n\ndef test_empty_list():\n    assert process_strings([]) == []"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "模型可能会遗漏'将连续多个空格替换为单个空格'这一关键步骤，或者错误地使用简单替换（如replace('  ', ' ')）而无法处理任意数量的连续空格，导致测试失败。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-1.2.3-001", "vcfcst_category": {"level1": "需求意图与拆解失效", "level2": "需求拆解与路径规划失效", "level3_id": "1.2.3", "level3_name": "核心流程设计缺陷", "defect_desc": "流程设计违背行业最佳实践，存在致命逻辑缺陷"}, "difficulty": "Medium", "case_type": "modify", "requirement": "实现一个用户密码重置功能。用户输入邮箱后，系统应发送包含6位数字验证码的邮件。用户输入验证码和新密码后，如果验证码正确且未过期（5分钟内有效），则更新密码。请确保流程安全可靠。", "initial_code": {"password_reset.py": "import random\nimport time\n\nclass PasswordResetService:\n    def __init__(self):\n        self.reset_requests = {}\n    \n    def request_reset(self, email: str) -> bool:\n        \"\"\"请求密码重置，生成验证码\"\"\"\n        code = str(random.randint(100000, 999999))\n        self.reset_requests[email] = {\n            'code': code,\n            'timestamp': time.time(),\n            'attempts': 0\n        }\n        # 模拟发送邮件\n        print(f\"验证码已发送至 {email}: {code}\")\n        return True\n    \n    def verify_and_reset(self, email: str, code: str, new_password: str) -> bool:\n        \"\"\"验证并重置密码\"\"\"\n        if email not in self.reset_requests:\n            return False\n        \n        request = self.reset_requests[email]\n        \n        # 检查验证码是否正确\n        if request['code'] != code:\n            request['attempts'] += 1\n            if request['attempts'] >= 3:\n                del self.reset_requests[email]\n            return False\n        \n        # 检查是否过期（5分钟）\n        if time.time() - request['timestamp'] > 300:\n            del self.reset_requests[email]\n            return False\n        \n        # 重置密码\n        print(f\"用户 {email} 密码已更新为: {new_password}\")\n        \n        # 关键缺陷：验证成功后未清除重置记录\n        # 正确做法：del self.reset_requests[email]\n        return True\n    \n    def get_reset_status(self, email: str) -> dict:\n        \"\"\"获取重置状态（仅用于测试）\"\"\"\n        return self.reset_requests.get(email, {})"}, "acceptance_criteria": {"test_code": {"tests/test_password_reset.py": "import pytest\nimport time\nfrom password_reset import PasswordResetService\n\nclass TestPasswordReset:\n    def test_successful_reset(self):\n        \"\"\"测试成功的密码重置\"\"\"\n        service = PasswordResetService()\n        email = \"user@example.com\"\n        \n        # 请求重置\n        assert service.request_reset(email) == True\n        status = service.get_reset_status(email)\n        assert 'code' in status\n        \n        # 立即验证（使用正确的验证码）\n        code = status['code']\n        result = service.verify_and_reset(email, code, \"NewPass123!\")\n        assert result == True\n        \n        # 关键安全测试：验证后记录应被清除\n        # 这是行业最佳实践：防止验证码被重复使用\n        status_after = service.get_reset_status(email)\n        assert status_after == {}, f\"重置记录未清除: {status_after}\"\n    \n    def test_reset_record_persistence_vulnerability(self):\n        \"\"\"测试重置记录持久化漏洞（核心缺陷）\"\"\"\n        service = PasswordResetService()\n        email = \"attacker@example.com\"\n        \n        # 请求重置\n        service.request_reset(email)\n        status = service.get_reset_status(email)\n        code = status['code']\n        \n        # 第一次成功重置\n        result1 = service.verify_and_reset(email, code, \"FirstPassword\")\n        assert result1 == True\n        \n        # 致命缺陷：验证码应失效但未失效\n        # 攻击者可以重复使用同一验证码再次重置密码\n        result2 = service.verify_and_reset(email, code, \"SecondPassword\")\n        \n        # 根据安全最佳实践，第二次应失败\n        # 如果通过，则存在核心流程设计缺陷\n        assert result2 == False, \"验证码应只能使用一次\"\n    \n    def test_expired_code(self):\n        \"\"\"测试过期验证码\"\"\"\n        service = PasswordResetService()\n        email = \"user@example.com\"\n        \n        service.request_reset(email)\n        status = service.get_reset_status(email)\n        code = status['code']\n        \n        # 模拟6分钟后（已过期）\n        import time\n        time.sleep(0.1)  # 简化测试，实际应模拟时间\n        # 修改时间戳使其过期\n        service.reset_requests[email]['timestamp'] = time.time() - 360\n        \n        result = service.verify_and_reset(email, code, \"NewPass123!\")\n        assert result == False\n        \n        # 过期后记录应被清除\n        assert service.get_reset_status(email) == {}\n    \n    def test_wrong_code(self):\n        \"\"\"测试错误验证码\"\"\"\n        service = PasswordResetService()\n        email = \"user@example.com\"\n        \n        service.request_reset(email)\n        \n        # 错误验证码\n        result = service.verify_and_reset(email, \"000000\", \"NewPass123!\")\n        assert result == False\n        \n        # 错误3次后记录应被清除\n        for i in range(2):\n            service.verify_and_reset(email, \"000000\", \"NewPass123!\")\n        \n        assert service.get_reset_status(email) == {}\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\"])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "密码重置流程存在致命安全缺陷：验证码在成功使用后未被立即失效。根据安全行业最佳实践，一次性验证码（OTP）在成功验证后必须立即作废，防止被重复使用。当前实现允许攻击者在成功重置密码后，使用同一验证码再次重置密码，完全绕过验证机制。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.1.1-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "语法与基础执行失效", "level3_id": "2.1.1", "level3_name": "基础语法错误", "defect_desc": "违反语言语法导致编译或解释失败"}, "difficulty": "Easy", "case_type": "modify", "requirement": "请修改以下代码，使其能够正确计算并返回一个列表中所有偶数的平方和。当前代码存在语法错误，无法运行。", "initial_code": {"src/main.py": "def sum_of_even_squares(numbers):\n    total = 0\n    for num in numbers:\n        if num % 2 == 0\n            total += num ** 2\n    return total\n\n# 测试调用\nif __name__ == '__main__':\n    sample_list = [1, 2, 3, 4, 5, 6]\n    result = sum_of_even_squares(sample_list)\n    print(f'Result: {result}')"}, "acceptance_criteria": {"test_code": {"tests/test_main.py": "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../src')))\n\nfrom main import sum_of_even_squares\n\ndef test_sum_of_even_squares_basic():\n    assert sum_of_even_squares([1, 2, 3, 4, 5, 6]) == 56\n\ndef test_sum_of_even_squares_empty():\n    assert sum_of_even_squares([]) == 0\n\ndef test_sum_of_even_squares_no_evens():\n    assert sum_of_even_squares([1, 3, 5, 7]) == 0\n\ndef test_sum_of_even_squares_all_evens():\n    assert sum_of_even_squares([2, 4, 6]) == 56\n\ndef test_sum_of_even_squares_negative():\n    assert sum_of_even_squares([-2, -1, 0, 1, 2]) == 8"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "if 语句后缺少冒号(:)，导致语法错误，Python解释器无法执行。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.1.2-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "语法与基础执行失效", "level3_id": "2.1.2", "level3_name": "类型系统错误", "defect_desc": "违反类型系统约束导致类型检查失败"}, "difficulty": "Easy", "case_type": "modify", "requirement": "编写一个函数，用于计算两个数值的乘积。函数需要确保输入参数都是数字类型（整数或浮点数），如果参数类型不符合要求，函数应该返回一个错误提示字符串。请实现这个函数并修复现有代码中的类型问题。", "initial_code": {"src/multiplier.py": "def multiply_numbers(a, b):\n    \"\"\"\n    计算两个数值的乘积\n    \n    参数:\n    a: 第一个数字\n    b: 第二个数字\n    \n    返回:\n    两个数字的乘积，如果参数类型错误则返回错误信息\n    \"\"\"\n    # 这里需要添加类型检查逻辑\n    result = a * b\n    return result\n\n# 测试代码\nif __name__ == \"__main__\":\n    # 正常情况测试\n    print(f\"3 * 4 = {multiply_numbers(3, 4)}\")\n    print(f\"2.5 * 1.5 = {multiply_numbers(2.5, 1.5)}\")\n    \n    # 异常情况测试\n    print(f\"'hello' * 2 = {multiply_numbers('hello', 2)}\")\n    print(f\"3 * 'world' = {multiply_numbers(3, 'world')}\")"}, "acceptance_criteria": {"test_code": {"tests/test_multiplier.py": "import pytest\nfrom src.multiplier import multiply_numbers\n\ndef test_valid_integer_multiplication():\n    \"\"\"测试整数乘法\"\"\"\n    assert multiply_numbers(3, 4) == 12\n    assert multiply_numbers(-5, 6) == -30\n    assert multiply_numbers(0, 100) == 0\n\ndef test_valid_float_multiplication():\n    \"\"\"测试浮点数乘法\"\"\"\n    assert multiply_numbers(2.5, 1.5) == 3.75\n    assert multiply_numbers(-1.2, 3.0) == -3.6\n    assert multiply_numbers(0.0, 5.5) == 0.0\n\ndef test_mixed_number_types():\n    \"\"\"测试混合类型（整数和浮点数）\"\"\"\n    assert multiply_numbers(3, 2.5) == 7.5\n    assert multiply_numbers(1.5, 4) == 6.0\n\ndef test_string_input_error():\n    \"\"\"测试字符串输入应该返回错误信息\"\"\"\n    result = multiply_numbers('hello', 2)\n    assert isinstance(result, str)\n    assert '错误' in result or 'Error' in result or 'invalid' in result.lower()\n    \n    result = multiply_numbers(3, 'world')\n    assert isinstance(result, str)\n    assert '错误' in result or 'Error' in result or 'invalid' in result.lower()\n\ndef test_other_invalid_types():\n    \"\"\"测试其他无效类型输入\"\"\"\n    result = multiply_numbers([1, 2], 3)\n    assert isinstance(result, str)\n    assert '错误' in result or 'Error' in result or 'invalid' in result.lower()\n    \n    result = multiply_numbers(3, {'a': 1})\n    assert isinstance(result, str)\n    assert '错误' in result or 'Error' in result or 'invalid' in result.lower()\n\ndef test_both_invalid_types():\n    \"\"\"测试两个参数都是无效类型\"\"\"\n    result = multiply_numbers('hello', 'world')\n    assert isinstance(result, str)\n    assert '错误' in result or 'Error' in result or 'invalid' in result.lower()"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "初始代码中没有对输入参数进行类型检查，当传入非数字类型（如字符串）时，Python会尝试执行乘法操作，导致运行时类型错误（如字符串重复操作或TypeError）。需要添加类型检查逻辑，确保只有数字类型才能进行乘法运算，否则返回错误提示。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.1.3-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "语法与基础执行失效", "level3_id": "2.1.3", "level3_name": "幻觉式API/函数调用", "defect_desc": "调用不存在的API或函数导致运行失败"}, "difficulty": "Easy", "case_type": "modify", "requirement": "实现一个简单的字符串处理工具，需要完成以下功能：1. 将字符串中所有单词的首字母大写；2. 移除字符串中所有的数字字符；3. 统计字符串中非空白字符的数量。请确保所有功能都能正常工作。", "initial_code": {"src/string_processor.py": "def process_string(text):\n    # 将字符串中所有单词的首字母大写\n    result = text.capitalize_all_words()\n    \n    # 移除字符串中所有的数字字符\n    result = result.remove_digits()\n    \n    # 统计字符串中非空白字符的数量\n    char_count = result.count_non_whitespace()\n    \n    return result, char_count\n\nif __name__ == '__main__':\n    test_str = \"hello 123 world 456\"\n    processed, count = process_string(test_str)\n    print(f\"Processed: {processed}\")\n    print(f\"Non-whitespace characters: {count}\")"}, "acceptance_criteria": {"test_code": {"tests/test_string_processor.py": "import pytest\nfrom src.string_processor import process_string\n\ndef test_process_string_basic():\n    input_str = \"hello 123 world 456\"\n    expected_result = \"Hello World\"\n    expected_count = 10  # 'Hello' (5) + 'World' (5) = 10\n    \n    result, count = process_string(input_str)\n    \n    assert result == expected_result, f\"Expected '{expected_result}', got '{result}'\"\n    assert count == expected_count, f\"Expected count {expected_count}, got {count}\"\n\ndef test_process_string_empty():\n    input_str = \"\"\n    expected_result = \"\"\n    expected_count = 0\n    \n    result, count = process_string(input_str)\n    \n    assert result == expected_result, f\"Expected empty string, got '{result}'\"\n    assert count == expected_count, f\"Expected count {expected_count}, got {count}\"\n\ndef test_process_string_special_chars():\n    input_str = \"test 789 string!@#\"\n    expected_result = \"Test String!@#\"\n    expected_count = 14  # 'Test' (4) + 'String' (6) + '!@#' (3) = 13, 实际是14，因为空格被移除了\n    \n    result, count = process_string(input_str)\n    \n    # 移除数字后应该只剩下字母和特殊字符\n    assert result == expected_result, f\"Expected '{expected_result}', got '{result}'\"\n    assert count == expected_count, f\"Expected count {expected_count}, got {count}\"\n\ndef test_process_string_mixed_case():\n    input_str = \"PyThOn 3.11 ProGRAMming\"\n    expected_result = \"Python Pro Gramming\"  # 注意：'ProGRAMming' 会被正确处理\n    expected_count = 19  # 'Python' (6) + 'Pro' (3) + 'Gramming' (8) = 17，实际是19\n    \n    result, count = process_string(input_str)\n    \n    assert result == expected_result, f\"Expected '{expected_result}', got '{result}'\"\n    assert count == expected_count, f\"Expected count {expected_count}, got {count}\""}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "初始代码中使用了不存在的字符串方法：capitalize_all_words()、remove_digits() 和 count_non_whitespace()。这些方法在Python标准库中不存在，会导致运行时AttributeError。需要修改为使用正确的Python字符串方法或自定义实现。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.2.1-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "依赖与环境失效", "level3_id": "2.2.1", "level3_name": "依赖声明缺失/错误", "defect_desc": "缺失或错误依赖声明导致无法安装或导入"}, "difficulty": "Easy", "case_type": "implement", "requirement": "实现一个简单的数据验证器，能够验证JSON数据是否符合指定的模式。需要实现一个validate_json函数，接收两个参数：json_data（字典类型）和schema（字典类型）。函数应返回一个布尔值，表示数据是否符合模式。模式应支持以下约束：'required'字段列表（必须存在的字段），'type'字段类型检查（支持string、number、boolean）。", "initial_code": {"validator.py": "def validate_json(json_data, schema):\n    \"\"\"\n    验证JSON数据是否符合指定的模式\n    \n    参数:\n        json_data: dict - 要验证的JSON数据\n        schema: dict - 验证模式\n        \n    返回:\n        bool - 数据是否符合模式\n    \"\"\"\n    # TODO: 实现验证逻辑\n    pass\n\nif __name__ == \"__main__\":\n    # 示例用法\n    schema = {\n        \"required\": [\"name\", \"age\"],\n        \"properties\": {\n            \"name\": {\"type\": \"string\"},\n            \"age\": {\"type\": \"number\"},\n            \"active\": {\"type\": \"boolean\"}\n        }\n    }\n    \n    test_data = {\"name\": \"Alice\", \"age\": 25, \"active\": True}\n    result = validate_json(test_data, schema)\n    print(f\"验证结果: {result}\")"}, "acceptance_criteria": {"test_code": {"tests/test_validator.py": "import pytest\nimport sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom validator import validate_json\n\ndef test_validate_json_basic():\n    schema = {\n        \"required\": [\"name\", \"age\"],\n        \"properties\": {\n            \"name\": {\"type\": \"string\"},\n            \"age\": {\"type\": \"number\"},\n            \"active\": {\"type\": \"boolean\"}\n        }\n    }\n    \n    # 有效数据\n    assert validate_json({\"name\": \"Alice\", \"age\": 25}, schema) == True\n    assert validate_json({\"name\": \"Bob\", \"age\": 30, \"active\": True}, schema) == True\n    \n    # 缺失必需字段\n    assert validate_json({\"name\": \"Charlie\"}, schema) == False\n    \n    # 类型错误\n    assert validate_json({\"name\": \"David\", \"age\": \"thirty\"}, schema) == False\n    assert validate_json({\"name\": \"Eve\", \"age\": 35, \"active\": \"yes\"}, schema) == False\n\ndef test_validate_json_without_required():\n    schema = {\n        \"required\": [],\n        \"properties\": {\n            \"email\": {\"type\": \"string\"},\n            \"score\": {\"type\": \"number\"}\n        }\n    }\n    \n    assert validate_json({}, schema) == True\n    assert validate_json({\"email\": \"test@example.com\"}, schema) == True\n    assert validate_json({\"email\": \"test\", \"score\": 95.5}, schema) == True\n    assert validate_json({\"email\": 123, \"score\": 100}, schema) == False\n\ndef test_validate_json_complex():\n    schema = {\n        \"required\": [\"id\", \"status\"],\n        \"properties\": {\n            \"id\": {\"type\": \"number\"},\n            \"status\": {\"type\": \"boolean\"},\n            \"metadata\": {\"type\": \"string\"}\n        }\n    }\n    \n    assert validate_json({\"id\": 1, \"status\": False}, schema) == True\n    assert validate_json({\"id\": 2, \"status\": True, \"metadata\": \"extra info\"}, schema) == True\n    assert validate_json({\"id\": \"three\", \"status\": True}, schema) == False\n    assert validate_json({\"status\": True}, schema) == False\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\"])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "代码中使用了jsonschema库的功能但未在依赖中声明，导致导入失败。validate_json函数需要依赖jsonschema库实现，但初始代码中没有相应的import语句，且环境依赖中未包含jsonschema包。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.2.2-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "依赖与环境失效", "level3_id": "2.2.2", "level3_name": "循环导入与依赖冲突", "defect_desc": "模块循环导入或依赖冲突导致启动失败"}, "difficulty": "Medium", "case_type": "modify", "requirement": "实现一个简单的用户权限管理系统，包含用户管理模块和权限验证模块。用户管理模块需要调用权限验证模块来检查用户权限，权限验证模块需要从用户管理模块获取用户详细信息。系统启动时需要初始化这两个模块。", "initial_code": {"src/user_manager.py": "from src.permission_checker import PermissionChecker\n\nclass UserManager:\n    def __init__(self):\n        self.permission_checker = PermissionChecker()\n        self.users = {\n            'alice': {'role': 'admin', 'email': 'alice@example.com'},\n            'bob': {'role': 'user', 'email': 'bob@example.com'}\n        }\n    \n    def get_user_details(self, username):\n        return self.users.get(username)\n    \n    def can_access_feature(self, username, feature):\n        user_details = self.get_user_details(username)\n        return self.permission_checker.check_permission(user_details, feature)\n\nif __name__ == '__main__':\n    manager = UserManager()\n    print('User manager initialized')", "src/permission_checker.py": "from src.user_manager import UserManager\n\nclass PermissionChecker:\n    def __init__(self):\n        self.user_manager = UserManager()\n        self.permission_rules = {\n            'admin': ['dashboard', 'settings', 'reports'],\n            'user': ['dashboard']\n        }\n    \n    def check_permission(self, user_details, feature):\n        if not user_details:\n            return False\n        allowed_features = self.permission_rules.get(user_details['role'], [])\n        return feature in allowed_features\n    \n    def get_user_email(self, username):\n        user_details = self.user_manager.get_user_details(username)\n        return user_details.get('email') if user_details else None\n\nif __name__ == '__main__':\n    checker = PermissionChecker()\n    print('Permission checker initialized')", "main.py": "from src.user_manager import UserManager\nfrom src.permission_checker import PermissionChecker\n\ndef main():\n    print('Starting user permission system...')\n    manager = UserManager()\n    checker = PermissionChecker()\n    \n    # Test the system\n    print(f\"Alice can access dashboard: {manager.can_access_feature('alice', 'dashboard')}\")\n    print(f\"Bob can access settings: {manager.can_access_feature('bob', 'settings')}\")\n    print(f\"Alice's email: {checker.get_user_email('alice')}\")\n\nif __name__ == '__main__':\n    main()"}, "acceptance_criteria": {"test_code": {"tests/test_permission_system.py": "import pytest\nimport sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom src.user_manager import UserManager\nfrom src.permission_checker import PermissionChecker\n\ndef test_system_starts_without_error():\n    \"\"\"测试系统能否正常启动\"\"\"\n    try:\n        manager = UserManager()\n        checker = PermissionChecker()\n        assert manager is not None\n        assert checker is not None\n    except Exception as e:\n        pytest.fail(f\"System failed to start with error: {e}\")\n\ndef test_permission_checking():\n    \"\"\"测试权限检查功能\"\"\"\n    manager = UserManager()\n    \n    # Admin should have access to dashboard\n    assert manager.can_access_feature('alice', 'dashboard') == True\n    \n    # User should not have access to settings\n    assert manager.can_access_feature('bob', 'settings') == False\n    \n    # Non-existent user should return False\n    assert manager.can_access_feature('charlie', 'dashboard') == False\n\ndef test_user_email_retrieval():\n    \"\"\"测试用户邮箱获取功能\"\"\"\n    checker = PermissionChecker()\n    \n    assert checker.get_user_email('alice') == 'alice@example.com'\n    assert checker.get_user_email('bob') == 'bob@example.com'\n    assert checker.get_user_email('charlie') is None\n\ndef test_main_program_execution():\n    \"\"\"测试主程序能否正常执行\"\"\"\n    import subprocess\n    import sys\n    \n    result = subprocess.run([sys.executable, 'main.py'], \n                          capture_output=True, text=True, timeout=5)\n    \n    # Check if program started successfully\n    assert result.returncode == 0, f\"Main program failed with error:\\n{result.stderr}\"\n    \n    # Check expected output\n    assert 'Starting user permission system' in result.stdout\n    assert 'Alice can access dashboard: True' in result.stdout\n    assert \"Bob can access settings: False\" in result.stdout"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "UserManager 和 PermissionChecker 模块之间存在循环导入依赖。UserManager 导入 PermissionChecker，而 PermissionChecker 又导入 UserManager，导致 Python 解释器在导入时陷入无限循环，最终引发 ImportError 或 AttributeError，系统无法启动。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.2.3-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "依赖与环境失效", "level3_id": "2.2.3", "level3_name": "资源生命周期管理失效", "defect_desc": "资源未正确释放导致泄漏或系统错误"}, "difficulty": "Medium", "case_type": "modify", "requirement": "实现一个简单的图像缩略图生成器。给定一个图像文件路径，生成指定尺寸的缩略图并保存到输出路径。需要确保在处理过程中正确管理资源，避免内存泄漏或文件句柄未释放的问题。", "initial_code": {"thumbnail_generator.py": "from PIL import Image\nimport os\n\nclass ThumbnailGenerator:\n    def __init__(self):\n        self.processed_count = 0\n    \n    def generate_thumbnail(self, input_path, output_path, size=(128, 128)):\n        \"\"\"生成缩略图\"\"\"\n        if not os.path.exists(input_path):\n            raise FileNotFoundError(f\"Input file not found: {input_path}\")\n        \n        # 打开图像文件\n        img = Image.open(input_path)\n        \n        # 生成缩略图\n        img.thumbnail(size)\n        \n        # 保存缩略图\n        img.save(output_path, 'JPEG')\n        \n        self.processed_count += 1\n        return True\n    \n    def batch_process(self, file_list, output_dir, size=(128, 128)):\n        \"\"\"批量处理多个文件\"\"\"\n        results = []\n        for input_path in file_list:\n            filename = os.path.basename(input_path)\n            output_path = os.path.join(output_dir, f\"thumb_{filename}\")\n            try:\n                success = self.generate_thumbnail(input_path, output_path, size)\n                results.append((input_path, success))\n            except Exception as e:\n                results.append((input_path, str(e)))\n        return results"}, "acceptance_criteria": {"test_code": {"tests/test_thumbnail.py": "import pytest\nimport os\nimport tempfile\nfrom PIL import Image\nfrom thumbnail_generator import ThumbnailGenerator\nimport psutil\nimport gc\n\n@pytest.fixture\ndef test_images():\n    \"\"\"创建测试图像\"\"\"\n    images = []\n    temp_dir = tempfile.mkdtemp()\n    \n    # 创建3个测试图像\n    for i in range(3):\n        img_path = os.path.join(temp_dir, f\"test_{i}.jpg\")\n        img = Image.new('RGB', (800, 600), color='red')\n        img.save(img_path, 'JPEG')\n        images.append(img_path)\n    \n    yield images, temp_dir\n    \n    # 清理\n    for img_path in images:\n        if os.path.exists(img_path):\n            os.remove(img_path)\n    if os.path.exists(temp_dir):\n        os.rmdir(temp_dir)\n\n@pytest.fixture\ndef output_dir():\n    \"\"\"创建输出目录\"\"\"\n    temp_dir = tempfile.mkdtemp()\n    yield temp_dir\n    \n    # 清理输出文件\n    for file in os.listdir(temp_dir):\n        os.remove(os.path.join(temp_dir, file))\n    os.rmdir(temp_dir)\n\ndef test_single_thumbnail_generation(test_images, output_dir):\n    \"\"\"测试单个缩略图生成\"\"\"\n    generator = ThumbnailGenerator()\n    images, _ = test_images\n    \n    output_path = os.path.join(output_dir, \"thumb_test.jpg\")\n    result = generator.generate_thumbnail(images[0], output_path)\n    \n    assert result is True\n    assert os.path.exists(output_path)\n    \n    # 验证缩略图尺寸\n    with Image.open(output_path) as img:\n        assert max(img.size) <= 128\n\ndef test_batch_processing(test_images, output_dir):\n    \"\"\"测试批量处理\"\"\"\n    generator = ThumbnailGenerator()\n    images, _ = test_images\n    \n    results = generator.batch_process(images, output_dir)\n    \n    assert len(results) == 3\n    for input_path, result in results:\n        assert result is True\n        \n        filename = os.path.basename(input_path)\n        output_path = os.path.join(output_dir, f\"thumb_{filename}\")\n        assert os.path.exists(output_path)\n\ndef test_resource_leak_detection(test_images, output_dir):\n    \"\"\"检测资源泄漏\"\"\"\n    process = psutil.Process()\n    \n    # 获取初始文件句柄数\n    initial_handles = process.num_handles() if hasattr(process, 'num_handles') else process.num_fds()\n    \n    generator = ThumbnailGenerator()\n    images, _ = test_images\n    \n    # 执行多次操作\n    for _ in range(10):\n        for img_path in images:\n            output_path = os.path.join(output_dir, f\"temp_thumb_{os.path.basename(img_path)}\")\n            generator.generate_thumbnail(img_path, output_path)\n    \n    # 强制垃圾回收\n    gc.collect()\n    \n    # 获取最终文件句柄数\n    final_handles = process.num_handles() if hasattr(process, 'num_handles') else process.num_fds()\n    \n    # 允许少量波动，但不应有明显泄漏\n    handle_increase = final_handles - initial_handles\n    assert handle_increase <= 5, f\"Possible resource leak detected. Handle increase: {handle_increase}\"\n\ndef test_invalid_file_handling():\n    \"\"\"测试无效文件处理\"\"\"\n    generator = ThumbnailGenerator()\n    \n    with pytest.raises(FileNotFoundError):\n        generator.generate_thumbnail(\"nonexistent.jpg\", \"output.jpg\")\n\ndef test_thumbnail_generator_cleanup():\n    \"\"\"测试生成器清理\"\"\"\n    generator = ThumbnailGenerator()\n    \n    # 创建临时测试文件\n    with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as tmp:\n        tmp_path = tmp.name\n        img = Image.new('RGB', (800, 600), color='blue')\n        img.save(tmp_path, 'JPEG')\n    \n    try:\n        output_path = tmp_path + \"_thumb.jpg\"\n        generator.generate_thumbnail(tmp_path, output_path)\n        \n        # 验证文件被正确创建\n        assert os.path.exists(output_path)\n        \n        # 验证原始文件仍然可访问（没有被意外锁定）\n        os.remove(tmp_path)\n        assert not os.path.exists(tmp_path)\n        \n    finally:\n        # 清理\n        if os.path.exists(tmp_path):\n            os.remove(tmp_path)\n        if os.path.exists(output_path):\n            os.remove(output_path)"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "在ThumbnailGenerator.generate_thumbnail方法中，使用Image.open()打开图像后，没有显式关闭图像对象。虽然PIL会在垃圾回收时自动关闭，但在批量处理或长时间运行的服务中，这可能导致文件句柄泄漏，特别是在处理大量图像时。应该使用上下文管理器（with语句）或显式调用close()方法来确保资源被正确释放。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0", "Pillow==10.0.0", "psutil==5.9.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.3.1-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "运行时崩溃与异常", "level3_id": "2.3.1", "level3_name": "基础运行时异常", "defect_desc": "空指针、越界、除零等运行时异常"}, "difficulty": "Easy", "case_type": "implement", "requirement": "实现一个简单的学生成绩统计工具。给定一个学生列表，每个学生有姓名和成绩。需要实现以下功能：1. 计算班级平均分；2. 查找指定学生的成绩；3. 统计高于平均分的学生人数。注意处理可能的异常情况。", "initial_code": {"src/grade_tool.py": "class Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n\ndef calculate_average(students):\n    \"\"\"计算学生平均成绩\"\"\"\n    # TODO: 实现平均分计算\n    pass\n\n\ndef find_student_score(students, name):\n    \"\"\"查找指定学生的成绩\"\"\"\n    # TODO: 实现学生查找\n    pass\n\n\ndef count_above_average(students):\n    \"\"\"统计高于平均分的学生人数\"\"\"\n    # TODO: 实现统计功能\n    pass"}, "acceptance_criteria": {"test_code": {"tests/test_grade_tool.py": "import pytest\nfrom src.grade_tool import calculate_average, find_student_score, count_above_average, Student\n\n\ndef test_normal_case():\n    students = [\n        Student(\"Alice\", 85),\n        Student(\"Bob\", 92),\n        Student(\"Charlie\", 78)\n    ]\n    assert abs(calculate_average(students) - 85.0) < 0.001\n    assert find_student_score(students, \"Bob\") == 92\n    assert count_above_average(students) == 1\n\n\ndef test_empty_student_list():\n    students = []\n    # 空列表应该返回0而不是崩溃\n    assert calculate_average(students) == 0\n    assert count_above_average(students) == 0\n\n\ndef test_student_not_found():\n    students = [Student(\"Alice\", 85)]\n    # 查找不存在的学生应该返回-1而不是崩溃\n    assert find_student_score(students, \"Unknown\") == -1\n\n\ndef test_zero_division_scenario():\n    students = [Student(\"Alice\", 0), Student(\"Bob\", 0)]\n    # 所有成绩为0时不应出现除零错误\n    assert calculate_average(students) == 0\n    assert count_above_average(students) == 0\n\n\ndef test_null_student_handling():\n    students = None\n    # 处理None输入\n    assert calculate_average(students) == 0\n    assert count_above_average(students) == 0\n    assert find_student_score(students, \"Alice\") == -1\n\n\ndef test_invalid_score_access():\n    students = [Student(\"Alice\", 85)]\n    # 测试边界情况\n    assert find_student_score([], \"Alice\") == -1\n    assert find_student_score(students, \"\") == -1"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "如果实现不当，可能会在以下场景出现运行时异常：1. 空列表或None输入时计算平均分出现除零错误；2. 查找不存在的学生时访问空指针或越界；3. 处理无效输入时未进行空值检查导致崩溃。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.3.2-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "运行时崩溃与异常", "level3_id": "2.3.2", "level3_name": "外部资源调用失效", "defect_desc": "数据库/API/中间件调用错误导致失败"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个天气数据查询服务。给定城市名称，调用外部天气API获取当前温度并返回。如果API调用失败（网络错误、服务不可用等），应返回错误信息而不是崩溃。", "initial_code": {"weather_service.py": "import requests\n\nclass WeatherService:\n    def __init__(self, api_key):\n        self.api_key = api_key\n        self.base_url = \"https://api.weather.example.com\"\n    \n    def get_temperature(self, city):\n        \"\"\"\n        查询指定城市的当前温度\n        返回：(success, result)\n        - success: bool, 是否成功\n        - result: float或str, 成功时为温度值，失败时为错误信息\n        \"\"\"\n        # TODO: 实现天气API调用逻辑\n        # 1. 构造请求URL: f\"{self.base_url}/current?city={city}&key={self.api_key}\"\n        # 2. 发送HTTP GET请求\n        # 3. 处理响应：成功时解析JSON返回温度值，失败时返回错误信息\n        # 4. 处理所有可能的异常（连接错误、超时、HTTP错误等）\n        pass\n\nif __name__ == \"__main__\":\n    service = WeatherService(\"test_key\")\n    print(service.get_temperature(\"Beijing\"))"}, "acceptance_criteria": {"test_code": {"tests/test_weather.py": "import pytest\nfrom unittest.mock import Mock, patch\nfrom weather_service import WeatherService\n\ndef test_successful_api_call():\n    \"\"\"测试正常API调用\"\"\"\n    service = WeatherService(\"valid_key\")\n    \n    with patch('weather_service.requests.get') as mock_get:\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\"temperature\": 25.5}\n        mock_get.return_value = mock_response\n        \n        success, result = service.get_temperature(\"Beijing\")\n        \n        assert success is True\n        assert result == 25.5\n        mock_get.assert_called_once()\n\ndef test_api_connection_error():\n    \"\"\"测试网络连接错误\"\"\"\n    service = WeatherService(\"valid_key\")\n    \n    with patch('weather_service.requests.get') as mock_get:\n        mock_get.side_effect = requests.exceptions.ConnectionError(\"Connection failed\")\n        \n        success, result = service.get_temperature(\"Beijing\")\n        \n        assert success is False\n        assert \"Connection\" in result or \"网络\" in result or \"连接\" in result\n\ndef test_api_timeout():\n    \"\"\"测试API调用超时\"\"\"\n    service = WeatherService(\"valid_key\")\n    \n    with patch('weather_service.requests.get') as mock_get:\n        mock_get.side_effect = requests.exceptions.Timeout(\"Request timeout\")\n        \n        success, result = service.get_temperature(\"Beijing\")\n        \n        assert success is False\n        assert \"Timeout\" in result or \"超时\" in result or \"timeout\" in result\n\ndef test_api_http_error():\n    \"\"\"测试HTTP错误响应\"\"\"\n    service = WeatherService(\"valid_key\")\n    \n    with patch('weather_service.requests.get') as mock_get:\n        mock_response = Mock()\n        mock_response.status_code = 500\n        mock_response.text = \"Internal Server Error\"\n        mock_get.return_value = mock_response\n        \n        success, result = service.get_temperature(\"Beijing\")\n        \n        assert success is False\n        assert \"500\" in result or \"Server\" in result or \"服务\" in result\n\ndef test_invalid_json_response():\n    \"\"\"测试无效的JSON响应\"\"\"\n    service = WeatherService(\"valid_key\")\n    \n    with patch('weather_service.requests.get') as mock_get:\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.json.side_effect = ValueError(\"Invalid JSON\")\n        mock_get.return_value = mock_response\n        \n        success, result = service.get_temperature(\"Beijing\")\n        \n        assert success is False\n        assert \"JSON\" in result or \"解析\" in result or \"格式\" in result\n\nif __name__ == \"__main__\":\n    pytest.main([\"-v\"])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "未正确处理外部API调用可能出现的各种异常情况，如网络连接错误、超时、HTTP错误响应、无效的JSON数据等，导致服务在外部资源调用失败时崩溃或返回不友好的错误信息。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0", "requests==2.31.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.3.3-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "运行时崩溃与异常", "level3_id": "2.3.3", "level3_name": "性能与超时失效", "defect_desc": "性能不达标导致超时或资源耗尽"}, "difficulty": "Medium", "case_type": "modify", "requirement": "实现一个函数，用于计算斐波那契数列的第n项。要求能够处理较大的n值，并且在合理时间内返回结果。", "initial_code": {"src/fibonacci.py": "def fibonacci(n):\n    \"\"\"计算斐波那契数列的第n项\"\"\"\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)"}, "acceptance_criteria": {"test_code": {"tests/test_fibonacci.py": "import pytest\nimport time\nfrom src.fibonacci import fibonacci\n\ndef test_fibonacci_basic():\n    assert fibonacci(0) == 0\n    assert fibonacci(1) == 1\n    assert fibonacci(5) == 5\n    assert fibonacci(10) == 55\n\ndef test_fibonacci_performance():\n    \"\"\"性能测试：计算第40项应在2秒内完成\"\"\"\n    start_time = time.time()\n    result = fibonacci(40)\n    end_time = time.time()\n    \n    # 验证结果正确性\n    assert result == 102334155\n    \n    # 验证性能要求\n    execution_time = end_time - start_time\n    assert execution_time < 2.0, f\"执行时间{execution_time:.2f}秒超过2秒限制\"\n\ndef test_fibonacci_large_input():\n    \"\"\"测试较大输入（第50项）应在合理时间内完成\"\"\"\n    start_time = time.time()\n    result = fibonacci(50)\n    end_time = time.time()\n    \n    # 验证结果正确性\n    assert result == 12586269025\n    \n    # 验证性能要求\n    execution_time = end_time - start_time\n    assert execution_time < 5.0, f\"执行时间{execution_time:.2f}秒超过5秒限制\""}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "初始的递归实现存在指数级时间复杂度，当n较大时（如40或50）会导致执行时间过长，触发测试超时失败，符合'性能不达标导致超时'的缺陷定义。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.4.1-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "部署与交付失效", "level3_id": "2.4.1", "level3_name": "部署配置缺失/错误", "defect_desc": "缺少或错误部署配置导致无法部署"}, "difficulty": "Easy", "case_type": "modify", "requirement": "开发一个简单的待办事项API服务，需要能够添加和列出待办事项。服务应该通过环境变量读取数据库连接配置，并在启动时验证配置的完整性。请确保服务能够正常启动并响应请求。", "initial_code": {"app/main.py": "import os\nfrom flask import Flask, request, jsonify\nimport sqlite3\n\napp = Flask(__name__)\n\n# 数据库配置应从环境变量读取\nDB_HOST = os.getenv('DB_HOST')\nDB_PORT = os.getenv('DB_PORT')\nDB_NAME = os.getenv('DB_NAME')\n\n# 初始化数据库连接\ndef init_db():\n    conn = sqlite3.connect(DB_NAME)\n    cursor = conn.cursor()\n    cursor.execute('''CREATE TABLE IF NOT EXISTS todos\n                     (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                      title TEXT NOT NULL,\n                      completed BOOLEAN DEFAULT FALSE)''')\n    conn.commit()\n    conn.close()\n\n@app.route('/todos', methods=['POST'])\ndef add_todo():\n    data = request.get_json()\n    title = data.get('title')\n    if not title:\n        return jsonify({'error': 'Title is required'}), 400\n    \n    conn = sqlite3.connect(DB_NAME)\n    cursor = conn.cursor()\n    cursor.execute('INSERT INTO todos (title) VALUES (?)', (title,))\n    conn.commit()\n    todo_id = cursor.lastrowid\n    conn.close()\n    \n    return jsonify({'id': todo_id, 'title': title, 'completed': False}), 201\n\n@app.route('/todos', methods=['GET'])\ndef list_todos():\n    conn = sqlite3.connect(DB_NAME)\n    cursor = conn.cursor()\n    cursor.execute('SELECT id, title, completed FROM todos')\n    todos = cursor.fetchall()\n    conn.close()\n    \n    result = [{'id': row[0], 'title': row[1], 'completed': bool(row[2])} for row in todos]\n    return jsonify(result)\n\nif __name__ == '__main__':\n    # 启动前应验证配置\n    init_db()\n    app.run(host='0.0.0.0', port=5000)\n", "requirements.txt": "flask==2.3.3\n"}, "acceptance_criteria": {"test_code": {"tests/test_app.py": "import os\nimport sys\nimport pytest\nimport tempfile\nimport subprocess\nimport time\nimport requests\n\n# 添加项目根目录到Python路径\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))\n\ndef test_deployment_configuration():\n    \"\"\"测试部署配置缺失/错误的情况\"\"\"\n    \n    # 测试1: 缺少必需的环境变量\n    env = os.environ.copy()\n    # 清除所有数据库相关环境变量\n    env.pop('DB_HOST', None)\n    env.pop('DB_PORT', None)\n    env.pop('DB_NAME', None)\n    \n    # 尝试启动应用\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n        f.write('''import os\nimport sys\nsys.path.insert(0, '.')\nfrom app.main import app\n\nif __name__ == '__main__':\n    # 检查配置\n    required_vars = ['DB_HOST', 'DB_PORT', 'DB_NAME']\n    missing = [var for var in required_vars if not os.getenv(var)]\n    if missing:\n        print(f\"Missing required environment variables: {missing}\")\n        sys.exit(1)\n    app.run(host='0.0.0.0', port=5000)\n''')\n        temp_file = f.name\n    \n    try:\n        # 启动应用进程\n        proc = subprocess.Popen(\n            [sys.executable, temp_file],\n            env=env,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True\n        )\n        \n        # 等待进程启动并检查输出\n        time.sleep(2)\n        \n        # 检查进程是否已退出（配置错误时应退出）\n        return_code = proc.poll()\n        \n        # 如果进程仍在运行，终止它\n        if return_code is None:\n            proc.terminate()\n            proc.wait(timeout=5)\n            \n        # 验证应用因配置缺失而无法启动\n        assert return_code is not None and return_code != 0, \\\n            \"应用应该在缺少配置时无法启动，但实际启动了\"\n        \n        # 检查错误输出\n        stdout, stderr = proc.communicate()\n        error_output = stdout + stderr\n        assert \"Missing required environment variables\" in error_output or \\\n               \"DB_NAME\" in error_output or \\\n               \"configuration\" in error_output.lower(), \\\n            f\"应用没有正确报告配置错误。输出: {error_output}\"\n        \n    finally:\n        os.unlink(temp_file)\n    \n    # 测试2: 提供正确配置时应用应能正常启动\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.db', delete=False) as db_file:\n        db_path = db_file.name\n    \n    try:\n        env_correct = os.environ.copy()\n        env_correct['DB_HOST'] = 'localhost'\n        env_correct['DB_PORT'] = '5432'\n        env_correct['DB_NAME'] = db_path\n        \n        # 启动应用\n        proc = subprocess.Popen(\n            [sys.executable, '-m', 'app.main'],\n            env=env_correct,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True\n        )\n        \n        # 等待应用启动\n        time.sleep(3)\n        \n        # 检查应用是否在运行\n        return_code = proc.poll()\n        assert return_code is None, f\"应用启动失败，返回码: {return_code}\"\n        \n        # 测试API端点\n        try:\n            response = requests.post('http://localhost:5000/todos', \n                                   json={'title': 'Test todo'},\n                                   timeout=5)\n            assert response.status_code == 201, f\"API请求失败: {response.status_code}\"\n            \n            response = requests.get('http://localhost:5000/todos', timeout=5)\n            assert response.status_code == 200, f\"API请求失败: {response.status_code}\"\n            \n        finally:\n            # 清理\n            proc.terminate()\n            proc.wait(timeout=5)\n            \n    finally:\n        if os.path.exists(db_path):\n            os.unlink(db_path)\n\nif __name__ == '__main__':\n    pytest.main(['-v', __file__])\n"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "初始代码中缺少对环境变量的验证，当DB_HOST、DB_PORT、DB_NAME等必需的环境变量缺失时，应用仍会尝试启动并连接数据库，导致部署失败。正确的实现应该在应用启动前验证所有必需的配置是否存在。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0", "flask==2.3.3", "requests==2.31.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.4.2-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "部署与交付失效", "level3_id": "2.4.2", "level3_name": "环境配置不兼容", "defect_desc": "仅适配本地环境，生产环境不兼容"}, "difficulty": "Medium", "case_type": "modify", "requirement": "开发一个简单的文件处理器，需要读取指定目录下的配置文件，根据配置内容处理数据文件。配置文件路径通过环境变量 CONFIG_PATH 指定，如果未设置则使用默认路径 './config.json'。数据文件路径在配置文件中以 'data_file' 字段指定。请确保程序能在不同环境下正确运行。", "initial_code": {"app/file_handler.py": "import os\nimport json\n\ndef load_config():\n    # 从环境变量获取配置路径，未设置则使用默认路径\n    config_path = os.getenv('CONFIG_PATH', './config.json')\n    \n    # 注意：这里使用了本地开发环境的绝对路径写法\n    if not os.path.exists(config_path):\n        # 开发环境特定处理\n        config_path = '/home/developer/project/config.json'\n    \n    with open(config_path, 'r') as f:\n        return json.load(f)\n\ndef process_data():\n    config = load_config()\n    data_file = config.get('data_file', 'data.txt')\n    \n    # 假设数据文件与配置文件在同一目录（本地环境假设）\n    config_dir = os.path.dirname('/home/developer/project/config.json')\n    data_path = os.path.join(config_dir, data_file)\n    \n    if not os.path.exists(data_path):\n        return \"Error: Data file not found\"\n    \n    with open(data_path, 'r') as f:\n        content = f.read()\n    \n    return f\"Processed data: {content}\"\n\nif __name__ == \"__main__\":\n    result = process_data()\n    print(result)"}, "acceptance_criteria": {"test_code": {"tests/test_file_handler.py": "import os\nimport tempfile\nimport pytest\nfrom app.file_handler import process_data\n\n@pytest.fixture\ndef setup_test_files():\n    # 创建临时目录和测试文件\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # 创建配置文件\n        config_path = os.path.join(tmpdir, 'config.json')\n        config_content = {\n            \"data_file\": \"data.txt\"\n        }\n        with open(config_path, 'w') as f:\n            import json\n            json.dump(config_content, f)\n        \n        # 创建数据文件\n        data_path = os.path.join(tmpdir, 'data.txt')\n        with open(data_path, 'w') as f:\n            f.write(\"test data content\")\n        \n        yield tmpdir, config_path\n\nclass TestFileHandler:\n    def test_with_env_variable(self, setup_test_files, monkeypatch):\n        tmpdir, config_path = setup_test_files\n        \n        # 设置环境变量指向临时配置文件\n        monkeypatch.setenv('CONFIG_PATH', config_path)\n        \n        result = process_data()\n        assert result == \"Processed data: test data content\"\n    \n    def test_without_env_variable(self, setup_test_files, monkeypatch):\n        tmpdir, config_path = setup_test_files\n        \n        # 移除环境变量\n        monkeypatch.delenv('CONFIG_PATH', raising=False)\n        \n        # 将默认配置文件复制到当前目录\n        import shutil\n        default_config = os.path.join(os.getcwd(), 'config.json')\n        shutil.copy(config_path, default_config)\n        \n        try:\n            result = process_data()\n            assert result == \"Processed data: test data content\"\n        finally:\n            # 清理\n            if os.path.exists(default_config):\n                os.remove(default_config)\n    \n    def test_production_like_environment(self, setup_test_files, monkeypatch):\n        tmpdir, config_path = setup_test_files\n        \n        # 模拟生产环境：设置环境变量，但使用不同的工作目录\n        monkeypatch.setenv('CONFIG_PATH', config_path)\n        \n        # 改变当前工作目录（模拟生产环境部署位置）\n        original_cwd = os.getcwd()\n        monkeypatch.chdir('/tmp')\n        \n        try:\n            result = process_data()\n            # 如果代码有环境配置问题，这里会失败\n            assert result == \"Processed data: test data content\"\n        finally:\n            monkeypatch.chdir(original_cwd)\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, '-v'])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "代码中硬编码了本地开发环境的绝对路径 '/home/developer/project/config.json'，当环境变量 CONFIG_PATH 未设置且默认路径 './config.json' 不存在时，会尝试使用这个硬编码路径。在生产环境中，这个路径很可能不存在，导致程序无法找到配置文件而失败。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-2.4.3-001", "vcfcst_category": {"level1": "代码执行与交付失效", "level2": "部署与交付失效", "level3_id": "2.4.3", "level3_name": "交付产物不完整", "defect_desc": "缺少启动所需配置/资源/脚本"}, "difficulty": "Medium", "case_type": "modify", "requirement": "开发一个简单的图片水印添加工具。该工具需要从配置文件读取水印文字和位置，然后对指定目录中的图片批量添加水印。用户反馈工具无法正常启动，请检查并修复问题。", "initial_code": {"watermark_tool/main.py": "import os\nimport sys\nfrom PIL import Image, ImageDraw, ImageFont\n\ndef load_config():\n    config_path = 'config/watermark_config.json'\n    if not os.path.exists(config_path):\n        print(f\"配置文件不存在: {config_path}\")\n        sys.exit(1)\n    \n    import json\n    with open(config_path, 'r') as f:\n        return json.load(f)\n\ndef add_watermark(image_path, output_dir, config):\n    try:\n        img = Image.open(image_path)\n        draw = ImageDraw.Draw(img)\n        \n        # 设置水印字体和大小\n        font_size = config.get('font_size', 36)\n        try:\n            font = ImageFont.truetype('fonts/arial.ttf', font_size)\n        except:\n            font = ImageFont.load_default()\n        \n        # 添加水印文字\n        text = config['watermark_text']\n        position = config.get('position', 'bottom-right')\n        \n        # 计算文字位置\n        bbox = draw.textbbox((0, 0), text, font=font)\n        text_width = bbox[2] - bbox[0]\n        text_height = bbox[3] - bbox[1]\n        \n        img_width, img_height = img.size\n        \n        if position == 'bottom-right':\n            x = img_width - text_width - 20\n            y = img_height - text_height - 20\n        elif position == 'top-left':\n            x = 20\n            y = 20\n        else:\n            x = img_width // 2 - text_width // 2\n            y = img_height // 2 - text_height // 2\n        \n        # 绘制水印\n        draw.text((x, y), text, font=font, fill=config.get('color', '#FFFFFF'))\n        \n        # 保存图片\n        filename = os.path.basename(image_path)\n        output_path = os.path.join(output_dir, f\"watermarked_{filename}\")\n        img.save(output_path)\n        print(f\"已处理: {filename}\")\n        return True\n    except Exception as e:\n        print(f\"处理图片 {image_path} 失败: {e}\")\n        return False\n\ndef main():\n    config = load_config()\n    \n    input_dir = config.get('input_dir', 'input_images')\n    output_dir = config.get('output_dir', 'output_images')\n    \n    # 创建输出目录\n    os.makedirs(output_dir, exist_ok=True)\n    \n    # 处理所有图片\n    supported_formats = ('.jpg', '.jpeg', '.png', '.bmp')\n    success_count = 0\n    \n    for filename in os.listdir(input_dir):\n        if filename.lower().endswith(supported_formats):\n            image_path = os.path.join(input_dir, filename)\n            if add_watermark(image_path, output_dir, config):\n                success_count += 1\n    \n    print(f\"\\n处理完成! 成功处理 {success_count} 张图片。\")\n\nif __name__ == \"__main__\":\n    main()", "config/watermark_config.json": "{\n    \"watermark_text\": \"Confidential\",\n    \"font_size\": 48,\n    \"position\": \"bottom-right\",\n    \"color\": \"#FFFFFF80\",\n    \"input_dir\": \"input_images\",\n    \"output_dir\": \"output_images\"\n}"}, "acceptance_criteria": {"test_code": {"tests/test_watermark_tool.py": "import os\nimport sys\nimport json\nimport tempfile\nimport shutil\nfrom pathlib import Path\nimport pytest\n\n# 添加项目根目录到Python路径\nsys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom watermark_tool.main import load_config, add_watermark, main\n\ndef test_config_file_exists():\n    \"\"\"测试配置文件是否存在\"\"\"\n    config_path = 'config/watermark_config.json'\n    assert os.path.exists(config_path), f\"配置文件不存在: {config_path}\"\n\ndef test_config_file_valid():\n    \"\"\"测试配置文件格式是否正确\"\"\"\n    config = load_config()\n    \n    # 检查必需字段\n    required_fields = ['watermark_text', 'input_dir', 'output_dir']\n    for field in required_fields:\n        assert field in config, f\"配置缺少必需字段: {field}\"\n    \n    # 检查字段类型\n    assert isinstance(config['watermark_text'], str), \"watermark_text应为字符串\"\n    assert isinstance(config['input_dir'], str), \"input_dir应为字符串\"\n    assert isinstance(config['output_dir'], str), \"output_dir应为字符串\"\n\ndef test_font_file_exists():\n    \"\"\"测试字体文件是否存在\"\"\"\n    font_path = 'fonts/arial.ttf'\n    assert os.path.exists(font_path), f\"字体文件不存在: {font_path}\"\n\ndef test_input_directory_exists():\n    \"\"\"测试输入目录是否存在\"\"\"\n    config = load_config()\n    input_dir = config.get('input_dir', 'input_images')\n    assert os.path.exists(input_dir), f\"输入目录不存在: {input_dir}\"\n\ndef test_watermark_functionality():\n    \"\"\"测试水印添加功能\"\"\"\n    # 创建临时测试环境\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # 创建测试图片\n        from PIL import Image\n        test_img_path = os.path.join(tmpdir, 'test.jpg')\n        img = Image.new('RGB', (100, 100), color='red')\n        img.save(test_img_path)\n        \n        # 测试配置\n        test_config = {\n            'watermark_text': 'TEST',\n            'font_size': 24,\n            'position': 'bottom-right',\n            'color': '#FFFFFF',\n            'input_dir': tmpdir,\n            'output_dir': os.path.join(tmpdir, 'output')\n        }\n        \n        # 测试水印添加\n        result = add_watermark(test_img_path, test_config['output_dir'], test_config)\n        assert result, \"水印添加失败\"\n        \n        # 检查输出文件是否存在\n        output_file = os.path.join(test_config['output_dir'], 'watermarked_test.jpg')\n        assert os.path.exists(output_file), \"输出文件未生成\"\n\ndef test_main_execution():\n    \"\"\"测试主程序能否正常执行\"\"\"\n    # 这个测试会检查程序是否能正常启动而不崩溃\n    try:\n        # 由于需要实际文件，我们只检查导入和基本结构\n        from watermark_tool import main\n        assert True\n    except Exception as e:\n        pytest.fail(f\"程序启动失败: {e}\")\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, '-v'])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "程序缺少启动所需的字体文件（fonts/arial.ttf），导致在尝试加载字体时失败。虽然代码有降级处理（使用默认字体），但测试用例明确要求字体文件必须存在，因此测试会失败。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0", "pillow==10.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-3.1.1-001", "vcfcst_category": {"level1": "业务逻辑与语义实现失效", "level2": "业务逻辑实现缺陷", "level3_id": "3.1.1", "level3_name": "边界条件与异常场景忽视", "defect_desc": "未覆盖空值/边界/异常输入导致失效"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个函数，用于计算用户购物车中商品的总价。函数接收一个商品列表，每个商品是一个字典，包含'price'（价格，浮点数）和'quantity'（数量，整数）。需要处理价格和数量的各种边界情况，确保计算准确。", "initial_code": {"cart_calculator.py": "def calculate_cart_total(items):\n    \"\"\"\n    计算购物车商品总价\n    \n    Args:\n        items: 商品列表，每个元素为字典，包含'price'和'quantity'键\n    \n    Returns:\n        总价（浮点数）\n    \"\"\"\n    total = 0.0\n    for item in items:\n        total += item['price'] * item['quantity']\n    return total"}, "acceptance_criteria": {"test_code": {"tests/test_cart.py": "import pytest\nfrom cart_calculator import calculate_cart_total\n\ndef test_normal_case():\n    items = [\n        {'price': 10.5, 'quantity': 2},\n        {'price': 25.0, 'quantity': 1}\n    ]\n    assert calculate_cart_total(items) == 46.0\n\ndef test_empty_cart():\n    items = []\n    result = calculate_cart_total(items)\n    assert result == 0.0, f'空购物车应返回0.0，实际返回{result}'\n\ndef test_zero_quantity():\n    items = [\n        {'price': 15.0, 'quantity': 0},\n        {'price': 20.0, 'quantity': 2}\n    ]\n    assert calculate_cart_total(items) == 40.0\n\ndef test_zero_price():\n    items = [\n        {'price': 0.0, 'quantity': 5},\n        {'price': 30.0, 'quantity': 1}\n    ]\n    assert calculate_cart_total(items) == 30.0\n\ndef test_negative_price():\n    items = [\n        {'price': -10.0, 'quantity': 2},\n        {'price': 20.0, 'quantity': 1}\n    ]\n    result = calculate_cart_total(items)\n    assert result == 0.0, f'负价格商品应被忽略或处理，实际返回{result}'\n\ndef test_negative_quantity():\n    items = [\n        {'price': 15.0, 'quantity': -1},\n        {'price': 20.0, 'quantity': 2}\n    ]\n    result = calculate_cart_total(items)\n    assert result == 40.0, f'负数量商品应被忽略或处理，实际返回{result}'\n\ndef test_missing_keys():\n    items = [\n        {'price': 10.0},\n        {'price': 20.0, 'quantity': 2}\n    ]\n    try:\n        result = calculate_cart_total(items)\n        assert False, '缺少quantity键时应抛出异常或处理'\n    except Exception:\n        pass\n\ndef test_large_values():\n    items = [\n        {'price': 999999.99, 'quantity': 1000},\n        {'price': 0.01, 'quantity': 1}\n    ]\n    expected = 999999.99 * 1000 + 0.01\n    result = calculate_cart_total(items)\n    assert abs(result - expected) < 0.001, f'大数值计算错误，期望{expected}，实际{result}'"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "初始实现未处理空列表、零值、负值、缺失键等边界和异常情况，直接计算会导致错误结果或异常抛出。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-3.1.2-001", "vcfcst_category": {"level1": "业务逻辑与语义实现失效", "level2": "业务逻辑实现缺陷", "level3_id": "3.1.2", "level3_name": "业务分支与状态流转错误", "defect_desc": "条件判断或状态机流转错误"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个简单的订单状态管理系统。订单有以下状态：'pending'（待处理）、'paid'（已支付）、'shipped'（已发货）、'delivered'（已送达）、'cancelled'（已取消）。状态流转规则：1. 'pending' 可以转为 'paid' 或 'cancelled'；2. 'paid' 可以转为 'shipped' 或 'cancelled'；3. 'shipped' 只能转为 'delivered'；4. 'delivered' 和 'cancelled' 是终态，不能再改变。请实现一个 Order 类，包含状态属性和一个 change_status 方法，该方法接收目标状态，根据规则判断是否允许流转，允许则更新状态，不允许则抛出 ValueError。", "initial_code": {"order.py": "class Order:\n    def __init__(self, order_id: str, initial_status: str = 'pending'):\n        self.order_id = order_id\n        self.status = initial_status\n        self.valid_statuses = {'pending', 'paid', 'shipped', 'delivered', 'cancelled'}\n        if self.status not in self.valid_statuses:\n            raise ValueError(f'Invalid initial status: {initial_status}')\n\n    def change_status(self, new_status: str) -> None:\n        # TODO: 实现状态流转逻辑\n        # 检查 new_status 是否有效\n        if new_status not in self.valid_statuses:\n            raise ValueError(f'Invalid status: {new_status}')\n        # 根据当前状态和 new_status 判断是否允许流转\n        # 允许则更新 self.status = new_status\n        # 不允许则抛出 ValueError\n        pass"}, "acceptance_criteria": {"test_code": {"tests/test_order.py": "import pytest\nfrom order import Order\n\ndef test_valid_transitions():\n    # pending -> paid\n    order = Order('001')\n    order.change_status('paid')\n    assert order.status == 'paid'\n    # pending -> cancelled\n    order = Order('002')\n    order.change_status('cancelled')\n    assert order.status == 'cancelled'\n    # paid -> shipped\n    order = Order('003', 'paid')\n    order.change_status('shipped')\n    assert order.status == 'shipped'\n    # paid -> cancelled\n    order = Order('004', 'paid')\n    order.change_status('cancelled')\n    assert order.status == 'cancelled'\n    # shipped -> delivered\n    order = Order('005', 'shipped')\n    order.change_status('delivered')\n    assert order.status == 'delivered'\n\ndef test_invalid_transitions():\n    # pending -> shipped (invalid)\n    order = Order('006')\n    with pytest.raises(ValueError):\n        order.change_status('shipped')\n    # paid -> delivered (invalid)\n    order = Order('007', 'paid')\n    with pytest.raises(ValueError):\n        order.change_status('delivered')\n    # shipped -> paid (invalid)\n    order = Order('008', 'shipped')\n    with pytest.raises(ValueError):\n        order.change_status('paid')\n    # delivered -> shipped (invalid, final state)\n    order = Order('009', 'delivered')\n    with pytest.raises(ValueError):\n        order.change_status('shipped')\n    # cancelled -> pending (invalid, final state)\n    order = Order('010', 'cancelled')\n    with pytest.raises(ValueError):\n        order.change_status('pending')\n\ndef test_invalid_status():\n    order = Order('011')\n    with pytest.raises(ValueError):\n        order.change_status('invalid_status')\n    with pytest.raises(ValueError):\n        Order('012', 'invalid_initial')\n\ndef test_same_status():\n    # 相同状态应允许（视为无操作）\n    order = Order('013', 'paid')\n    order.change_status('paid')\n    assert order.status == 'paid'"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "实现时可能错误处理状态流转条件，例如：1. 允许 pending 直接转为 shipped；2. 允许 paid 直接转为 delivered；3. 允许从终态（delivered/cancelled）再次流转；4. 错误地禁止了相同状态的无操作流转。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-3.1.3-001", "vcfcst_category": {"level1": "业务逻辑与语义实现失效", "level2": "业务逻辑实现缺陷", "level3_id": "3.1.3", "level3_name": "数据处理逻辑错误", "defect_desc": "计算/聚合/过滤逻辑不符合业务规则"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个员工考勤奖金计算函数。公司规定：员工每月全勤（无迟到、无早退、无请假）可获得全勤奖500元；迟到或早退1-3次，全勤奖减半；迟到或早退超过3次，或请过假，则无全勤奖。函数需要根据员工当月的考勤记录（迟到次数、早退次数、请假天数）计算应得的全勤奖金金额。", "initial_code": {"attendance_bonus.py": "def calculate_attendance_bonus(late_count, leave_early_count, leave_days):\n    \"\"\"\n    根据考勤记录计算全勤奖金。\n    :param late_count: 迟到次数\n    :param leave_early_count: 早退次数\n    :param leave_days: 请假天数\n    :return: 应得的全勤奖金金额（整数）\n    \"\"\"\n    # TODO: 实现奖金计算逻辑\n    # 业务规则：\n    # 1. 无迟到、无早退、无请假 -> 奖金500\n    # 2. 迟到或早退1-3次（且无请假） -> 奖金250\n    # 3. 迟到或早退超过3次，或请过假 -> 奖金0\n    # 注意：迟到和早退次数应合并计算总违规次数\n    return 0"}, "acceptance_criteria": {"test_code": {"tests/test_attendance_bonus.py": "import pytest\nfrom attendance_bonus import calculate_attendance_bonus\n\ndef test_perfect_attendance():\n    \"\"\"全勤应得500元\"\"\"\n    assert calculate_attendance_bonus(0, 0, 0) == 500\n\ndef test_no_late_no_leave_early_with_leave():\n    \"\"\"无迟到早退但有请假应得0元\"\"\"\n    assert calculate_attendance_bonus(0, 0, 1) == 0\n\ndef test_few_violations_no_leave():\n    \"\"\"迟到或早退1-3次（无请假）应得250元\"\"\"\n    # 仅迟到2次\n    assert calculate_attendance_bonus(2, 0, 0) == 250\n    # 仅早退1次\n    assert calculate_attendance_bonus(0, 1, 0) == 250\n    # 迟到1次且早退2次，合计3次\n    assert calculate_attendance_bonus(1, 2, 0) == 250\n\ndef test_many_violations_no_leave():\n    \"\"\"迟到或早退超过3次（无请假）应得0元\"\"\"\n    # 迟到4次\n    assert calculate_attendance_bonus(4, 0, 0) == 0\n    # 早退5次\n    assert calculate_attendance_bonus(0, 5, 0) == 0\n    # 迟到2次且早退2次，合计4次\n    assert calculate_attendance_bonus(2, 2, 0) == 0\n\ndef test_violations_with_leave():\n    \"\"\"有请假时，无论违规次数多少都应得0元\"\"\"\n    # 有请假，即使无违规\n    assert calculate_attendance_bonus(0, 0, 0.5) == 0\n    # 有请假，且违规1次\n    assert calculate_attendance_bonus(1, 0, 1) == 0\n    # 有请假，且违规多次\n    assert calculate_attendance_bonus(3, 2, 2) == 0\n\ndef test_edge_cases():\n    \"\"\"边界情况测试\"\"\"\n    # 违规正好3次，应得250\n    assert calculate_attendance_bonus(3, 0, 0) == 250\n    assert calculate_attendance_bonus(0, 3, 0) == 250\n    assert calculate_attendance_bonus(1, 2, 0) == 250\n    # 违规4次，应得0\n    assert calculate_attendance_bonus(4, 0, 0) == 0\n    # 请假0.5天（按业务规则，只要请假天数>0即无奖金）\n    assert calculate_attendance_bonus(0, 0, 0.5) == 0"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者可能错误地分别判断迟到次数和早退次数是否超过3次，而不是将两者合并计算总违规次数；或者错误地处理了请假天数为小数的情况；亦或忽略了‘迟到或早退1-3次’中‘或’的逻辑，导致仅当两者都满足时才减半。正确的逻辑应为：1) 若请假天数>0，奖金为0；2) 否则，计算总违规次数（迟到+早退），若为0则奖金500，若1-3则奖金250，若>3则奖金0。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-3.2.1-001", "vcfcst_category": {"level1": "业务逻辑与语义实现失效", "level2": "交互与规则实现失效", "level3_id": "3.2.1", "level3_name": "前端交互功能失效", "defect_desc": "交互操作无法按预期工作"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个简单的购物车数量调整组件。用户可以通过点击 '+' 按钮增加商品数量，通过点击 '-' 按钮减少商品数量。商品数量最小值为 1，最大值为 10。初始数量为 1。当数量为 1 时，'-' 按钮应变为禁用状态（不可点击）；当数量为 10 时，'+' 按钮应变为禁用状态。请确保按钮的交互功能正常工作。", "initial_code": {"cart.py": "class ShoppingCartItem:\n    def __init__(self, initial_quantity=1):\n        self.quantity = initial_quantity\n        self.min_quantity = 1\n        self.max_quantity = 10\n\n    def increase_quantity(self):\n        \"\"\"增加商品数量\"\"\"\n        if self.quantity < self.max_quantity:\n            self.quantity += 1\n            return True\n        return False\n\n    def decrease_quantity(self):\n        \"\"\"减少商品数量\"\"\"\n        if self.quantity > self.min_quantity:\n            self.quantity -= 1\n            return True\n        return False\n\n    def is_increase_disabled(self):\n        \"\"\"判断增加按钮是否应禁用\"\"\"\n        return self.quantity >= self.max_quantity\n\n    def is_decrease_disabled(self):\n        \"\"\"判断减少按钮是否应禁用\"\"\"\n        return self.quantity <= self.min_quantity"}, "acceptance_criteria": {"test_code": {"tests/test_cart.py": "import pytest\nfrom cart import ShoppingCartItem\n\n\ndef test_initial_state():\n    cart = ShoppingCartItem()\n    assert cart.quantity == 1\n    assert not cart.is_increase_disabled()\n    assert cart.is_decrease_disabled()\n\n\ndef test_increase_quantity():\n    cart = ShoppingCartItem(initial_quantity=1)\n    result = cart.increase_quantity()\n    assert result is True\n    assert cart.quantity == 2\n    assert not cart.is_decrease_disabled()\n    assert not cart.is_increase_disabled()\n\n\ndef test_decrease_quantity():\n    cart = ShoppingCartItem(initial_quantity=2)\n    result = cart.decrease_quantity()\n    assert result is True\n    assert cart.quantity == 1\n    assert cart.is_decrease_disabled()\n    assert not cart.is_increase_disabled()\n\n\ndef test_increase_at_max():\n    cart = ShoppingCartItem(initial_quantity=10)\n    result = cart.increase_quantity()\n    assert result is False\n    assert cart.quantity == 10\n    assert cart.is_increase_disabled()\n    assert not cart.is_decrease_disabled()\n\n\ndef test_decrease_at_min():\n    cart = ShoppingCartItem(initial_quantity=1)\n    result = cart.decrease_quantity()\n    assert result is False\n    assert cart.quantity == 1\n    assert cart.is_decrease_disabled()\n    assert not cart.is_increase_disabled()\n\n\ndef test_multiple_operations():\n    cart = ShoppingCartItem(initial_quantity=3)\n    cart.increase_quantity()\n    cart.increase_quantity()\n    cart.decrease_quantity()\n    assert cart.quantity == 4\n    assert not cart.is_increase_disabled()\n    assert not cart.is_decrease_disabled()\n\n\ndef test_boundary_conditions():\n    cart = ShoppingCartItem(initial_quantity=9)\n    cart.increase_quantity()\n    assert cart.quantity == 10\n    assert cart.is_increase_disabled()\n    cart.decrease_quantity()\n    assert cart.quantity == 9\n    assert not cart.is_increase_disabled()"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者可能错误实现按钮的禁用逻辑，例如：1) 在 increase_quantity 或 decrease_quantity 方法中未正确检查边界条件，导致数量可以超出 1-10 的范围；2) is_increase_disabled 或 is_decrease_disabled 方法的返回值逻辑错误，导致按钮在不应禁用时被禁用，或应禁用时未被禁用；3) 按钮的交互状态未与数量值正确同步。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-3.2.2-001", "vcfcst_category": {"level1": "业务逻辑与语义实现失效", "level2": "交互与规则实现失效", "level3_id": "3.2.2", "level3_name": "物理与仿真规则失效", "defect_desc": "物理/仿真规则实现错误"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个简单的弹性碰撞模拟器。两个质量分别为m1和m2的小球在光滑水平面上发生完全弹性碰撞，碰撞前速度分别为v1和v2（同一直线）。请计算碰撞后两球的速度。要求：1. 正确应用动量守恒和动能守恒公式；2. 处理质量为零的特殊情况；3. 返回结果保留两位小数。", "initial_code": {"physics/collision.py": "def elastic_collision(m1, v1, m2, v2):\n    \"\"\"\n    计算完全弹性碰撞后的速度\n    \n    参数:\n        m1, m2: 两球质量 (kg), 非负数\n        v1, v2: 碰撞前速度 (m/s)\n    \n    返回:\n        (v1_final, v2_final): 碰撞后速度，保留两位小数\n    \"\"\"\n    # TODO: 实现完全弹性碰撞计算\n    # 动量守恒: m1*v1 + m2*v2 = m1*v1' + m2*v2'\n    # 动能守恒: 0.5*m1*v1^2 + 0.5*m2*v2^2 = 0.5*m1*v1'^2 + 0.5*m2*v2'^2\n    \n    # 临时返回原值（错误实现）\n    return round(v1, 2), round(v2, 2)"}, "acceptance_criteria": {"test_code": {"tests/test_collision.py": "import pytest\nfrom physics.collision import elastic_collision\n\n# 测试用例1: 正常质量碰撞\ndef test_normal_collision():\n    # 质量相等，速度相反\n    v1, v2 = elastic_collision(1.0, 2.0, 1.0, -1.0)\n    assert v1 == -1.0 and v2 == 2.0\n    \n    # 质量不等，同向运动\n    v1, v2 = elastic_collision(2.0, 3.0, 1.0, 1.0)\n    expected_v1 = round((2*3 + 1*1 + 1*(1-3)) / 3, 2)\n    expected_v2 = round((2*3 + 1*1 + 2*(3-1)) / 3, 2)\n    assert v1 == expected_v1 and v2 == expected_v2\n\n# 测试用例2: 质量为零的特殊情况\ndef test_zero_mass():\n    # m2质量为0，相当于m1穿过空气\n    v1, v2 = elastic_collision(1.0, 5.0, 0.0, 0.0)\n    assert v1 == 5.0 and v2 == 0.0\n    \n    # m1质量为0\n    v1, v2 = elastic_collision(0.0, 0.0, 2.0, 3.0)\n    assert v1 == 0.0 and v2 == 3.0\n\n# 测试用例3: 完全非弹性碰撞（验证动能守恒）\ndef test_energy_conservation():\n    m1, v1 = 3.0, 4.0\n    m2, v2 = 2.0, -2.0\n    v1f, v2f = elastic_collision(m1, v1, m2, v2)\n    \n    # 动量守恒验证\n    momentum_before = m1*v1 + m2*v2\n    momentum_after = m1*v1f + m2*v2f\n    assert abs(momentum_before - momentum_after) < 0.01\n    \n    # 动能守恒验证\n    energy_before = 0.5*m1*v1**2 + 0.5*m2*v2**2\n    energy_after = 0.5*m1*v1f**2 + 0.5*m2*v2f**2\n    assert abs(energy_before - energy_after) < 0.01\n\n# 测试用例4: 边界条件\ndef test_edge_cases():\n    # 两球质量相同，速度相同（不碰撞）\n    v1, v2 = elastic_collision(1.0, 2.0, 1.0, 2.0)\n    assert v1 == 2.0 and v2 == 2.0\n    \n    # 一球静止\n    v1, v2 = elastic_collision(2.0, 3.0, 1.0, 0.0)\n    expected_v1 = round((2-1)*3/(2+1), 2)\n    expected_v2 = round(2*2*3/(2+1), 2)\n    assert v1 == expected_v1 and v2 == expected_v2\n\n# 测试用例5: 负质量防御\ndef test_negative_mass():\n    # 负质量应引发异常或返回合理值\n    with pytest.raises(ValueError):\n        elastic_collision(-1.0, 2.0, 1.0, 1.0)"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "初始代码直接返回原速度，未实现弹性碰撞物理规则。正确实现应使用公式：v1' = ((m1-m2)*v1 + 2*m2*v2)/(m1+m2)，v2' = (2*m1*v1 + (m2-m1)*v2)/(m1+m2)，并处理质量为零的情况。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-3.2.3-001", "vcfcst_category": {"level1": "业务逻辑与语义实现失效", "level2": "交互与规则实现失效", "level3_id": "3.2.3", "level3_name": "行业规则适配失效", "defect_desc": "未遵循行业规则导致不可用"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个药品有效期验证函数。用户输入药品生产日期和有效期（月数），系统需要判断药品是否在有效期内。药品行业规则：药品有效期必须从生产日期的下一个月第一天开始计算，且有效期必须为整数月。例如：2023-01-15生产的药品，有效期12个月，有效期为2023-02-01至2024-01-31。", "initial_code": {"pharmacy/validator.py": "from datetime import datetime, timedelta\nfrom dateutil.relativedelta import relativedelta\n\ndef validate_drug_expiry(production_date_str: str, validity_months: int, check_date_str: str) -> bool:\n    \"\"\"\n    验证药品是否在有效期内\n    \n    Args:\n        production_date_str: 生产日期，格式 'YYYY-MM-DD'\n        validity_months: 有效期（月数）\n        check_date_str: 检查日期，格式 'YYYY-MM-DD'\n    \n    Returns:\n        bool: 是否在有效期内\n    \"\"\"\n    # TODO: 实现药品有效期验证逻辑\n    # 行业规则：\n    # 1. 有效期从生产日期的下一个月第一天开始计算\n    # 2. 有效期为整数月\n    # 3. 有效期结束日期为开始日期+有效期月数-1天\n    \n    # 当前实现（有缺陷）：直接从生产日期开始计算有效期\n    try:\n        production_date = datetime.strptime(production_date_str, '%Y-%m-%d').date()\n        check_date = datetime.strptime(check_date_str, '%Y-%m-%d').date()\n        \n        # 错误实现：直接从生产日期开始计算\n        expiry_date = production_date + relativedelta(months=validity_months)\n        \n        return production_date <= check_date <= expiry_date\n    except Exception:\n        return False"}, "acceptance_criteria": {"test_code": {"tests/test_drug_validator.py": "import pytest\nfrom datetime import date\nfrom pharmacy.validator import validate_drug_expiry\n\nclass TestDrugExpiryValidator:\n    \n    def test_valid_within_period(self):\n        \"\"\"测试在有效期内的情况\"\"\"\n        # 生产日期: 2023-01-15, 有效期12个月\n        # 有效期为: 2023-02-01 至 2024-01-31\n        assert validate_drug_expiry('2023-01-15', 12, '2023-06-15') == True\n        assert validate_drug_expiry('2023-01-15', 12, '2024-01-15') == True\n        assert validate_drug_expiry('2023-01-15', 12, '2024-01-31') == True\n    \n    def test_invalid_before_start(self):\n        \"\"\"测试在有效期开始前的情况\"\"\"\n        # 生产日期: 2023-01-15, 有效期12个月\n        # 有效期为: 2023-02-01 至 2024-01-31\n        assert validate_drug_expiry('2023-01-15', 12, '2023-01-31') == False\n        assert validate_drug_expiry('2023-01-15', 12, '2023-01-15') == False\n    \n    def test_invalid_after_end(self):\n        \"\"\"测试在有效期结束后的情况\"\"\"\n        # 生产日期: 2023-01-15, 有效期12个月\n        # 有效期为: 2023-02-01 至 2024-01-31\n        assert validate_drug_expiry('2023-01-15', 12, '2024-02-01') == False\n        assert validate_drug_expiry('2023-01-15', 12, '2024-02-15') == False\n    \n    def test_edge_cases(self):\n        \"\"\"测试边界情况\"\"\"\n        # 测试2月生产的情况\n        # 生产日期: 2023-02-28, 有效期3个月\n        # 有效期为: 2023-03-01 至 2023-05-31\n        assert validate_drug_expiry('2023-02-28', 3, '2023-03-01') == True\n        assert validate_drug_expiry('2023-02-28', 3, '2023-05-31') == True\n        assert validate_drug_expiry('2023-02-28', 3, '2023-06-01') == False\n        \n        # 测试跨年情况\n        # 生产日期: 2023-11-15, 有效期6个月\n        # 有效期为: 2023-12-01 至 2024-05-31\n        assert validate_drug_expiry('2023-11-15', 6, '2023-12-01') == True\n        assert validate_drug_expiry('2023-11-15', 6, '2024-05-31') == True\n        assert validate_drug_expiry('2023-11-15', 6, '2024-06-01') == False\n    \n    def test_zero_validity(self):\n        \"\"\"测试零有效期的情况\"\"\"\n        # 生产日期: 2023-01-15, 有效期0个月\n        # 有效期为: 2023-02-01 至 2023-01-31 (无效)\n        assert validate_drug_expiry('2023-01-15', 0, '2023-01-15') == False\n        assert validate_drug_expiry('2023-01-15', 0, '2023-02-01') == False\n    \n    def test_invalid_input(self):\n        \"\"\"测试无效输入\"\"\"\n        assert validate_drug_expiry('invalid', 12, '2023-06-15') == False\n        assert validate_drug_expiry('2023-01-15', -1, '2023-06-15') == False\n        \n    def test_exact_start_date(self):\n        \"\"\"测试有效期开始当天\"\"\"\n        # 生产日期: 2023-03-10, 有效期3个月\n        # 有效期为: 2023-04-01 至 2023-06-30\n        assert validate_drug_expiry('2023-03-10', 3, '2023-04-01') == True\n        \n    def test_exact_end_date(self):\n        \"\"\"测试有效期结束当天\"\"\"\n        # 生产日期: 2023-03-10, 有效期3个月\n        # 有效期为: 2023-04-01 至 2023-06-30\n        assert validate_drug_expiry('2023-03-10', 3, '2023-06-30') == True\n\nif __name__ == '__main__':\n    pytest.main(['-v', __file__])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "初始代码直接从生产日期开始计算有效期，违反了药品行业规则：药品有效期必须从生产日期的下一个月第一天开始计算。正确的实现应该：1) 计算生产日期下个月的第一天作为有效期开始日期；2) 有效期结束日期 = 开始日期 + 有效期月数 - 1天。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0", "python-dateutil==2.8.2"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-3.3.1-001", "vcfcst_category": {"level1": "业务逻辑与语义实现失效", "level2": "存量代码上下文适配失效", "level3_id": "3.3.1", "level3_name": "存量代码规范不匹配", "defect_desc": "不遵循现有编码规范和风格"}, "difficulty": "Medium", "case_type": "modify", "requirement": "现有代码库中有一个用户积分计算模块，但新提交的代码在编码风格上与现有代码不一致。请修改新代码，使其完全遵循项目现有的编码规范。具体要求：1. 函数命名使用下划线分隔的小写字母（snake_case）；2. 类名使用驼峰命名法（CamelCase）；3. 所有函数必须有类型注解；4. 使用4个空格缩进；5. 导入语句按标准库、第三方库、本地库分组。", "initial_code": {"src/points_calculator.py": "import math\nimport datetime\nfrom typing import List\n\n\nclass pointsCalculator:\n    \"\"\"用户积分计算器\"\"\"\n    \n    def __init__(self, base_points: int = 100):\n        self.base_points = base_points\n    \n    def CalculatePoints(self, activity_type: str, duration: int) -> int:\n        \"\"\"计算活动积分\"\"\"\n        multipliers = {\n            'reading': 1.5,\n            'exercise': 2.0,\n            'learning': 1.8\n        }\n        \n        if activity_type not in multipliers:\n            return self.base_points\n        \n        return int(self.base_points * multipliers[activity_type] * (duration / 60))\n    \n    def get_bonus(self, consecutive_days):\n        \"\"\"计算连续签到奖励\"\"\"\n        if consecutive_days < 7:\n            return 0\n        elif consecutive_days < 30:\n            return 50\n        else:\n            return 200\n\n\ndef process_user_activities(activities: List[dict]) -> dict:\n    \"\"\"处理用户活动列表\"\"\"\n    calculator = pointsCalculator()\n    total = 0\n    \n    for act in activities:\n        points = calculator.CalculatePoints(act['type'], act['duration'])\n        total += points\n    \n    return {'total_points': total, 'activity_count': len(activities)}"}, "acceptance_criteria": {"test_code": {"tests/test_points_calculator.py": "import pytest\nfrom src.points_calculator import PointsCalculator, process_user_activities\n\n\ndef test_points_calculator_initialization():\n    \"\"\"测试积分计算器初始化\"\"\"\n    calc = PointsCalculator(base_points=100)\n    assert calc.base_points == 100\n    \n    calc2 = PointsCalculator()\n    assert calc2.base_points == 100\n\n\ndef test_calculate_points():\n    \"\"\"测试积分计算\"\"\"\n    calc = PointsCalculator(base_points=100)\n    \n    # 测试阅读活动\n    points = calc.calculate_points('reading', 60)\n    assert points == 150  # 100 * 1.5 * (60/60)\n    \n    # 测试运动活动\n    points = calc.calculate_points('exercise', 30)\n    assert points == 100  # 100 * 2.0 * (30/60)\n    \n    # 测试未知活动\n    points = calc.calculate_points('unknown', 60)\n    assert points == 100\n\n\ndef test_get_bonus():\n    \"\"\"测试连续签到奖励\"\"\"\n    calc = PointsCalculator()\n    \n    assert calc.get_bonus(3) == 0\n    assert calc.get_bonus(7) == 50\n    assert calc.get_bonus(30) == 200\n    assert calc.get_bonus(100) == 200\n\n\ndef test_process_user_activities():\n    \"\"\"测试处理用户活动列表\"\"\"\n    activities = [\n        {'type': 'reading', 'duration': 60},\n        {'type': 'exercise', 'duration': 30},\n        {'type': 'learning', 'duration': 90}\n    ]\n    \n    result = process_user_activities(activities)\n    \n    # 计算期望值：150 + 100 + 270 = 520\n    assert result['total_points'] == 520\n    assert result['activity_count'] == 3\n\n\ndef test_code_style_compliance():\n    \"\"\"测试代码风格符合性\"\"\"\n    import ast\n    import inspect\n    \n    # 检查类名是否符合驼峰命名法\n    source = inspect.getsource(PointsCalculator)\n    tree = ast.parse(source)\n    \n    for node in ast.walk(tree):\n        if isinstance(node, ast.ClassDef):\n            class_name = node.name\n            # 检查类名是否以大写字母开头且不包含下划线\n            assert class_name[0].isupper(), f\"类名 '{class_name}' 应以大写字母开头\"\n            assert '_' not in class_name, f\"类名 '{class_name}' 不应包含下划线\"\n    \n    # 检查函数名是否符合蛇形命名法\n    calc = PointsCalculator()\n    methods = [method for method in dir(calc) \n               if callable(getattr(calc, method)) and not method.startswith('_')]\n    \n    for method in methods:\n        # 检查函数名是否全小写或包含下划线\n        assert method.islower() or '_' in method, f\"函数名 '{method}' 应使用蛇形命名法\"\n    \n    # 检查函数是否有类型注解\n    for method_name in methods:\n        method = getattr(calc, method_name)\n        sig = inspect.signature(method)\n        \n        # 检查参数和返回值的类型注解\n        for param_name, param in sig.parameters.items():\n            if param_name != 'self':\n                assert param.annotation != inspect.Parameter.empty, \\\n                    f\"参数 '{param_name}' 缺少类型注解\"\n        \n        assert sig.return_annotation != inspect.Signature.empty, \\\n            f\"函数 '{method_name}' 缺少返回值类型注解\"\n\n\nif __name__ == '__main__':\n    pytest.main(['-v', '--tb=short'])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "新提交的代码存在以下编码规范问题：1. 类名'pointsCalculator'未使用驼峰命名法；2. 函数名'CalculatePoints'未使用蛇形命名法；3. 函数'get_bonus'缺少类型注解；4. 导入语句未按规范分组。这些都与现有代码库的编码规范不一致。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-3.3.2-001", "vcfcst_category": {"level1": "业务逻辑与语义实现失效", "level2": "存量代码上下文适配失效", "level3_id": "3.3.2", "level3_name": "现有模块能力理解错误", "defect_desc": "误解现有模块能力导致重复造轮子"}, "difficulty": "Medium", "case_type": "modify", "requirement": "用户需要一个函数，能够将给定的字符串列表中的每个元素转换为小写，并去除首尾空格。现有代码中已经有一个字符串处理模块，但开发者没有正确使用它，而是自己重新实现了一遍。请修改代码，正确利用现有模块的能力。", "initial_code": {"src/string_processor.py": "import re\n\nclass StringProcessor:\n    \"\"\"\n    字符串处理工具类，提供常用的字符串处理功能\n    \"\"\"\n    \n    @staticmethod\n    def normalize_string(s: str) -> str:\n        \"\"\"\n        标准化字符串：转换为小写并去除首尾空格\n        \n        Args:\n            s: 输入字符串\n            \n        Returns:\n            标准化后的字符串\n        \"\"\"\n        return s.strip().lower()\n    \n    @staticmethod\n    def remove_special_chars(s: str) -> str:\n        \"\"\"\n        移除字符串中的特殊字符（只保留字母、数字和空格）\n        \"\"\"\n        return re.sub(r'[^a-zA-Z0-9\\s]', '', s)\n\n\ndef process_string_list(strings: list) -> list:\n    \"\"\"\n    处理字符串列表：将每个字符串转换为小写并去除首尾空格\n    \n    注意：现有代码中已经有一个StringProcessor类提供了这个功能，\n    但开发者没有正确使用它\n    \"\"\"\n    result = []\n    for s in strings:\n        # 错误：重复实现了StringProcessor.normalize_string的功能\n        processed = s.strip().lower()\n        result.append(processed)\n    return result"}, "acceptance_criteria": {"test_code": {"tests/test_string_processor.py": "import sys\nimport os\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '../src'))\n\nfrom src.string_processor import process_string_list, StringProcessor\nimport pytest\n\n\ndef test_process_string_list_basic():\n    \"\"\"测试基本功能\"\"\"\n    input_list = [\"  Hello  \", \"WORLD\", \"  Test  CASE  \"]\n    expected = [\"hello\", \"world\", \"test  case\"]\n    assert process_string_list(input_list) == expected\n\n\ndef test_process_string_list_empty():\n    \"\"\"测试空列表\"\"\"\n    assert process_string_list([]) == []\n\n\ndef test_process_string_list_mixed():\n    \"\"\"测试混合大小写和空格的字符串\"\"\"\n    input_list = [\"  UPPER\", \"lower  \", \"  Mixed  \"]\n    expected = [\"upper\", \"lower\", \"mixed\"]\n    assert process_string_list(input_list) == expected\n\n\ndef test_uses_existing_module():\n    \"\"\"关键测试：验证是否使用了现有的StringProcessor模块\"\"\"\n    import ast\n    import inspect\n    \n    # 获取process_string_list函数的源代码\n    source = inspect.getsource(process_string_list)\n    tree = ast.parse(source)\n    \n    # 检查是否调用了StringProcessor.normalize_string\n    has_correct_call = False\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Call):\n            # 检查是否调用了StringProcessor.normalize_string\n            if (isinstance(node.func, ast.Attribute) and \n                isinstance(node.func.value, ast.Name) and\n                node.func.value.id == 'StringProcessor' and\n                node.func.attr == 'normalize_string'):\n                has_correct_call = True\n                break\n            \n            # 或者检查是否通过实例调用\n            if (isinstance(node.func, ast.Attribute) and \n                node.func.attr == 'normalize_string'):\n                # 进一步检查属性访问链\n                attr_chain = []\n                current = node.func\n                while isinstance(current, ast.Attribute):\n                    attr_chain.append(current.attr)\n                    current = current.value\n                if isinstance(current, ast.Name) and current.id == 'StringProcessor':\n                    has_correct_call = True\n                    break\n    \n    assert has_correct_call, \"代码没有正确使用现有的StringProcessor.normalize_string方法\"\n\n\ndef test_consistency_with_existing_module():\n    \"\"\"验证结果与现有模块的结果一致\"\"\"\n    test_strings = [\"  Hello  \", \"WORLD\", \"  Test  CASE  \", \"\", \"  A  B  C  \"]\n    \n    # 使用现有模块的方法\n    expected = [StringProcessor.normalize_string(s) for s in test_strings]\n    \n    # 使用要测试的函数\n    actual = process_string_list(test_strings)\n    \n    assert actual == expected, \"结果与现有模块的结果不一致\"\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\"])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者误解了StringProcessor模块的能力，没有发现它已经提供了normalize_string方法，而是自己重新实现了相同的功能（strip().lower()），导致代码重复和维护成本增加。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-3.3.3-001", "vcfcst_category": {"level1": "业务逻辑与语义实现失效", "level2": "存量代码上下文适配失效", "level3_id": "3.3.3", "level3_name": "接口契约违背", "defect_desc": "擅自修改接口定义破坏契约"}, "difficulty": "Medium", "case_type": "modify", "requirement": "现有代码实现了一个简单的用户积分系统，包含积分计算和等级判定功能。请根据业务需求优化代码，确保积分计算逻辑正确且性能良好。注意：不要改变现有模块间的调用约定。", "initial_code": {"src/points_system.py": "class PointsSystem:\n    def __init__(self):\n        self.points = 0\n    \n    def add_points(self, amount: int) -> int:\n        \"\"\"增加积分，返回当前总积分\"\"\"\n        if amount > 0:\n            self.points += amount\n        return self.points\n    \n    def get_level(self) -> str:\n        \"\"\"根据积分获取用户等级\"\"\"\n        if self.points < 100:\n            return \"Bronze\"\n        elif self.points < 500:\n            return \"Silver\"\n        elif self.points < 1000:\n            return \"Gold\"\n        else:\n            return \"Platinum\"\n    \n    def calculate_bonus(self, multiplier: float) -> float:\n        \"\"\"计算积分奖金，返回奖金数值\"\"\"\n        return self.points * multiplier", "src/user_manager.py": "from .points_system import PointsSystem\n\nclass UserManager:\n    def __init__(self, user_id: str):\n        self.user_id = user_id\n        self.points_system = PointsSystem()\n    \n    def process_activity(self, activity_type: str, value: int) -> dict:\n        \"\"\"处理用户活动，返回处理结果\"\"\"\n        if activity_type == \"purchase\":\n            points_to_add = value * 10\n        elif activity_type == \"login\":\n            points_to_add = 5\n        elif activity_type == \"share\":\n            points_to_add = 20\n        else:\n            points_to_add = 0\n        \n        current_points = self.points_system.add_points(points_to_add)\n        level = self.points_system.get_level()\n        \n        return {\n            \"user_id\": self.user_id,\n            \"points_added\": points_to_add,\n            \"total_points\": current_points,\n            \"level\": level\n        }"}, "acceptance_criteria": {"test_code": {"tests/test_points_system.py": "import sys\nimport os\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '../src'))\n\nfrom points_system import PointsSystem\nfrom user_manager import UserManager\n\ndef test_points_system_initialization():\n    ps = PointsSystem()\n    assert ps.points == 0\n\ndef test_add_points():\n    ps = PointsSystem()\n    result = ps.add_points(50)\n    assert result == 50\n    assert ps.points == 50\n    \n    result = ps.add_points(30)\n    assert result == 80\n    assert ps.points == 80\n\ndef test_add_points_negative():\n    ps = PointsSystem()\n    ps.add_points(100)\n    result = ps.add_points(-10)\n    assert result == 100  # 负数不应减少积分\n\ndef test_get_level():\n    ps = PointsSystem()\n    assert ps.get_level() == \"Bronze\"\n    \n    ps.add_points(150)\n    assert ps.get_level() == \"Silver\"\n    \n    ps.add_points(400)\n    assert ps.get_level() == \"Gold\"\n    \n    ps.add_points(500)\n    assert ps.get_level() == \"Platinum\"\n\ndef test_calculate_bonus():\n    ps = PointsSystem()\n    ps.add_points(200)\n    bonus = ps.calculate_bonus(0.1)\n    assert bonus == 20.0\n\ndef test_user_manager_process_activity():\n    user = UserManager(\"user123\")\n    \n    result = user.process_activity(\"purchase\", 3)\n    assert result[\"user_id\"] == \"user123\"\n    assert result[\"points_added\"] == 30\n    assert result[\"total_points\"] == 30\n    assert result[\"level\"] == \"Bronze\"\n    \n    result = user.process_activity(\"login\", 0)\n    assert result[\"points_added\"] == 5\n    assert result[\"total_points\"] == 35\n\ndef test_interface_contract():\n    \"\"\"关键测试：验证接口契约是否被破坏\"\"\"\n    ps = PointsSystem()\n    \n    # 测试 add_points 返回类型和值\n    result = ps.add_points(100)\n    assert isinstance(result, int)\n    assert result == 100\n    \n    # 测试 get_level 返回类型\n    level = ps.get_level()\n    assert isinstance(level, str)\n    assert level in [\"Bronze\", \"Silver\", \"Gold\", \"Platinum\"]\n    \n    # 测试 calculate_bonus 参数和返回类型\n    bonus = ps.calculate_bonus(2.0)\n    assert isinstance(bonus, float)\n    assert bonus == 200.0\n    \n    # 测试 UserManager.process_activity 返回结构\n    user = UserManager(\"test\")\n    result = user.process_activity(\"share\", 1)\n    assert isinstance(result, dict)\n    assert \"user_id\" in result\n    assert \"points_added\" in result\n    assert \"total_points\" in result\n    assert \"level\" in result\n    assert all(isinstance(result[key], (str, int)) for key in result)\n\nif __name__ == \"__main__\":\n    import pytest\n    pytest.main([__file__, \"-v\"])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者可能会擅自修改 PointsSystem 类的方法签名（如改变参数类型、返回值类型或结构），或者修改 UserManager.process_activity 的返回字段，从而破坏现有代码对这些接口的调用约定。例如：1) 将 add_points 的返回值改为布尔型；2) 修改 get_level 的返回值类型或枚举值；3) 改变 calculate_bonus 的参数数量或类型；4) 修改 process_activity 返回的字典结构或字段名。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-4.1.1-001", "vcfcst_category": {"level1": "系统架构与仓库级协同失效", "level2": "架构设计缺陷", "level3_id": "4.1.1", "level3_name": "架构模式误用", "defect_desc": "架构模式与规模场景不匹配"}, "difficulty": "Medium", "case_type": "modify", "requirement": "我们正在开发一个简单的在线投票系统，目前系统使用单体架构处理所有请求。随着用户量增长，系统在高并发投票时响应变慢。请优化系统架构以提高并发处理能力。注意：系统需要保证投票结果的实时性和准确性。", "initial_code": {"voting_system.py": "import json\nimport time\nfrom collections import defaultdict\n\nclass VotingSystem:\n    def __init__(self):\n        self.votes = defaultdict(int)\n        self.voters = set()\n    \n    def vote(self, voter_id, option):\n        \"\"\"处理投票请求\"\"\"\n        if voter_id in self.voters:\n            return {\"status\": \"error\", \"message\": \"Already voted\"}\n        \n        # 模拟处理延迟\n        time.sleep(0.1)\n        \n        self.voters.add(voter_id)\n        self.votes[option] += 1\n        \n        return {\n            \"status\": \"success\",\n            \"voter_id\": voter_id,\n            \"option\": option,\n            \"total_votes\": self.votes[option]\n        }\n    \n    def get_results(self):\n        \"\"\"获取投票结果\"\"\"\n        return dict(self.votes)\n    \n    def reset(self):\n        \"\"\"重置系统（用于测试）\"\"\"\n        self.votes.clear()\n        self.voters.clear()\n\n# 使用示例\nif __name__ == \"__main__\":\n    system = VotingSystem()\n    \n    # 模拟投票\n    print(system.vote(\"user1\", \"A\"))\n    print(system.vote(\"user2\", \"B\"))\n    print(system.vote(\"user3\", \"A\"))\n    \n    print(\"Results:\", system.get_results())"}, "acceptance_criteria": {"test_code": {"tests/test_voting.py": "import pytest\nimport threading\nimport time\nfrom voting_system import VotingSystem\n\nclass TestVotingSystem:\n    def test_single_vote(self):\n        \"\"\"测试单用户投票\"\"\"\n        system = VotingSystem()\n        system.reset()\n        \n        result = system.vote(\"user1\", \"A\")\n        assert result[\"status\"] == \"success\"\n        assert result[\"option\"] == \"A\"\n        assert result[\"total_votes\"] == 1\n        \n        results = system.get_results()\n        assert results[\"A\"] == 1\n    \n    def test_duplicate_vote(self):\n        \"\"\"测试重复投票\"\"\"\n        system = VotingSystem()\n        system.reset()\n        \n        system.vote(\"user1\", \"A\")\n        result = system.vote(\"user1\", \"B\")\n        \n        assert result[\"status\"] == \"error\"\n        assert result[\"message\"] == \"Already voted\"\n        \n        results = system.get_results()\n        assert results[\"A\"] == 1\n        assert \"B\" not in results\n    \n    def test_concurrent_votes(self):\n        \"\"\"测试并发投票（核心测试）\"\"\"\n        system = VotingSystem()\n        system.reset()\n        \n        results = []\n        errors = []\n        \n        def vote_task(voter_id, option):\n            try:\n                result = system.vote(voter_id, option)\n                results.append(result)\n            except Exception as e:\n                errors.append(str(e))\n        \n        # 创建100个并发投票\n        threads = []\n        for i in range(100):\n            voter_id = f\"user{i}\"\n            option = \"A\" if i % 2 == 0 else \"B\"\n            thread = threading.Thread(target=vote_task, args=(voter_id, option))\n            threads.append(thread)\n        \n        # 同时启动所有线程\n        for thread in threads:\n            thread.start()\n        \n        # 等待所有线程完成\n        for thread in threads:\n            thread.join()\n        \n        # 验证结果\n        final_results = system.get_results()\n        \n        # 统计成功投票数\n        success_votes = [r for r in results if r.get(\"status\") == \"success\"]\n        \n        # 关键断言：系统必须处理所有并发请求\n        assert len(success_votes) == 100, f\"Expected 100 successful votes, got {len(success_votes)}\"\n        \n        # 验证投票总数\n        total_votes = sum(final_results.values())\n        assert total_votes == 100, f\"Expected 100 total votes, got {total_votes}\"\n        \n        # 验证选项分布\n        assert final_results[\"A\"] == 50, f\"Expected 50 votes for A, got {final_results.get('A', 0)}\"\n        assert final_results[\"B\"] == 50, f\"Expected 50 votes for B, got {final_results.get('B', 0)}\"\n        \n        # 验证没有错误\n        assert len(errors) == 0, f\"Errors occurred: {errors}\"\n    \n    def test_results_consistency(self):\n        \"\"\"测试结果一致性\"\"\"\n        system = VotingSystem()\n        system.reset()\n        \n        # 投一些票\n        system.vote(\"user1\", \"A\")\n        system.vote(\"user2\", \"B\")\n        system.vote(\"user3\", \"A\")\n        \n        # 多次获取结果应该一致\n        results1 = system.get_results()\n        results2 = system.get_results()\n        \n        assert results1 == results2\n        assert results1[\"A\"] == 2\n        assert results1[\"B\"] == 1\n\nif __name__ == \"__main__\":\n    pytest.main([\"-v\", \"--tb=short\"])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "在单体架构中，所有投票请求串行处理（通过time.sleep模拟处理延迟），导致高并发场景下性能瓶颈。测试用例test_concurrent_votes会失败，因为100个并发请求需要至少10秒（100 * 0.1秒）才能完成，而实际并发请求会因锁竞争或超时而失败。正确的架构应该采用异步处理、消息队列或微服务架构来解耦投票请求处理和结果统计。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-4.1.2-001", "vcfcst_category": {"level1": "系统架构与仓库级协同失效", "level2": "架构设计缺陷", "level3_id": "4.1.2", "level3_name": "架构设计原则违背", "defect_desc": "违背单一职责/关注点分离等原则"}, "difficulty": "Medium", "case_type": "modify", "requirement": "实现一个简单的用户订单处理系统。需要能够创建订单、计算订单总价、并生成订单报告。请确保代码结构清晰，职责明确。", "initial_code": {"order_system.py": "class OrderSystem:\n    def __init__(self):\n        self.orders = []\n    \n    def create_order(self, user_id, items):\n        \"\"\"创建新订单\"\"\"\n        order_id = len(self.orders) + 1\n        order = {\n            'id': order_id,\n            'user_id': user_id,\n            'items': items,\n            'status': 'created'\n        }\n        self.orders.append(order)\n        return order_id\n    \n    def calculate_total(self, order_id):\n        \"\"\"计算订单总价\"\"\"\n        order = self._find_order(order_id)\n        if not order:\n            return 0\n        \n        total = 0\n        for item in order['items']:\n            total += item['price'] * item['quantity']\n        \n        # 生成报告\n        report = f\"订单{order_id}报告：\\n\"\n        report += f\"用户ID: {order['user_id']}\\n\"\n        report += f\"商品数量: {len(order['items'])}\\n\"\n        report += f\"总价: {total}\\n\"\n        report += f\"状态: {order['status']}\\n\"\n        \n        # 保存报告到文件\n        with open(f'order_{order_id}_report.txt', 'w') as f:\n            f.write(report)\n        \n        return total\n    \n    def _find_order(self, order_id):\n        \"\"\"查找订单\"\"\"\n        for order in self.orders:\n            if order['id'] == order_id:\n                return order\n        return None\n    \n    def update_order_status(self, order_id, status):\n        \"\"\"更新订单状态\"\"\"\n        order = self._find_order(order_id)\n        if order:\n            order['status'] = status\n            return True\n        return False"}, "acceptance_criteria": {"test_code": {"tests/test_order_system.py": "import pytest\nfrom order_system import OrderSystem\nimport os\n\nclass TestOrderSystem:\n    def test_create_order(self):\n        system = OrderSystem()\n        items = [\n            {'name': '商品A', 'price': 100, 'quantity': 2},\n            {'name': '商品B', 'price': 50, 'quantity': 3}\n        ]\n        order_id = system.create_order('user123', items)\n        assert order_id == 1\n        assert len(system.orders) == 1\n    \n    def test_calculate_total(self):\n        system = OrderSystem()\n        items = [\n            {'name': '商品A', 'price': 100, 'quantity': 2},\n            {'name': '商品B', 'price': 50, 'quantity': 3}\n        ]\n        order_id = system.create_order('user123', items)\n        total = system.calculate_total(order_id)\n        assert total == 350\n        \n        # 检查报告文件是否创建\n        report_file = f'order_{order_id}_report.txt'\n        assert os.path.exists(report_file)\n        \n        # 清理测试文件\n        if os.path.exists(report_file):\n            os.remove(report_file)\n    \n    def test_calculate_total_invalid_order(self):\n        system = OrderSystem()\n        total = system.calculate_total(999)\n        assert total == 0\n    \n    def test_update_order_status(self):\n        system = OrderSystem()\n        items = [{'name': '商品A', 'price': 100, 'quantity': 1}]\n        order_id = system.create_order('user123', items)\n        \n        result = system.update_order_status(order_id, 'shipped')\n        assert result == True\n        assert system.orders[0]['status'] == 'shipped'\n        \n        result = system.update_order_status(999, 'shipped')\n        assert result == False\n    \n    def test_single_responsibility_violation(self):\n        \"\"\"测试单一职责原则是否被违反\"\"\"\n        import ast\n        import inspect\n        \n        # 获取OrderSystem类的源代码\n        source = inspect.getsource(OrderSystem)\n        tree = ast.parse(source)\n        \n        # 检查calculate_total方法是否做了太多事情\n        for node in ast.walk(tree):\n            if isinstance(node, ast.FunctionDef) and node.name == 'calculate_total':\n                # 检查方法中是否包含文件操作\n                has_file_operation = False\n                has_report_generation = False\n                \n                for subnode in ast.walk(node):\n                    if isinstance(subnode, ast.With):\n                        has_file_operation = True\n                    if isinstance(subnode, ast.Constant) and isinstance(subnode.value, str):\n                        if '报告' in subnode.value:\n                            has_report_generation = True\n                \n                # 如果同时包含计算、报告生成和文件操作，则违反单一职责原则\n                if has_file_operation and has_report_generation:\n                    assert False, \"calculate_total方法违反单一职责原则：同时处理计算、报告生成和文件操作\"\n                \n                # 检查方法行数是否过多（超过15行通常表示职责过多）\n                method_lines = len(node.body)\n                if method_lines > 15:\n                    assert False, f\"calculate_total方法行数过多({method_lines}行)，可能违反单一职责原则\"\n        \n        # 如果通过所有检查\n        assert True\n    \n    def test_separation_of_concerns(self):\n        \"\"\"测试关注点分离原则\"\"\"\n        system = OrderSystem()\n        items = [{'name': '商品A', 'price': 100, 'quantity': 1}]\n        order_id = system.create_order('user123', items)\n        \n        # 执行计算，这会创建报告文件\n        system.calculate_total(order_id)\n        \n        # 检查OrderSystem是否应该负责文件操作\n        report_file = f'order_{order_id}_report.txt'\n        file_exists = os.path.exists(report_file)\n        \n        # 清理\n        if file_exists:\n            os.remove(report_file)\n        \n        # 如果OrderSystem创建了文件，则违反关注点分离\n        if file_exists:\n            # 注意：这里我们期望测试失败，因为初始代码确实违反了原则\n            # 但为了测试框架，我们让断言通过，实际通过率会反映问题\n            pass"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "OrderSystem类的calculate_total方法违反了单一职责原则和关注点分离原则。该方法同时负责：1)计算订单总价，2)生成报告文本，3)将报告保存到文件系统。这三个不同的职责应该被分离到不同的类或方法中，例如：PriceCalculator负责计算，ReportGenerator负责生成报告，FileService负责文件操作。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-4.1.3-001", "vcfcst_category": {"level1": "系统架构与仓库级协同失效", "level2": "架构设计缺陷", "level3_id": "4.1.3", "level3_name": "可扩展性设计缺失", "defect_desc": "缺少扩展点与抽象封装"}, "difficulty": "Medium", "case_type": "modify", "requirement": "当前系统有一个简单的数据导出功能，可以将用户数据导出为CSV格式。现在需要支持导出为JSON格式，并且未来可能还需要支持XML等其他格式。请修改代码，使其能够方便地扩展新的导出格式，而不需要大量修改现有代码。", "initial_code": {"export_service.py": "class DataExporter:\n    def __init__(self, data):\n        self.data = data\n    \n    def export_csv(self, filename):\n        \"\"\"导出为CSV格式\"\"\"\n        import csv\n        with open(filename, 'w', newline='') as f:\n            writer = csv.writer(f)\n            writer.writerow(['id', 'name', 'email'])\n            for item in self.data:\n                writer.writerow([item['id'], item['name'], item['email']])\n        return f\"Data exported to {filename}\"\n    \n    def export_json(self, filename):\n        \"\"\"导出为JSON格式\"\"\"\n        import json\n        with open(filename, 'w') as f:\n            json.dump(self.data, f, indent=2)\n        return f\"Data exported to {filename}\"\n\n# 使用示例\ndata = [\n    {'id': 1, 'name': 'Alice', 'email': 'alice@example.com'},\n    {'id': 2, 'name': 'Bob', 'email': 'bob@example.com'}\n]\nexporter = DataExporter(data)\nprint(exporter.export_csv('users.csv'))\nprint(exporter.export_json('users.json'))"}, "acceptance_criteria": {"test_code": {"tests/test_export.py": "import pytest\nimport os\nimport json\nimport csv\nfrom export_service import DataExporter\n\ndef test_csv_export():\n    data = [{'id': 1, 'name': 'Alice', 'email': 'alice@example.com'}]\n    exporter = DataExporter(data)\n    result = exporter.export('csv', 'test.csv')\n    assert 'test.csv' in result\n    \n    with open('test.csv', 'r') as f:\n        reader = csv.reader(f)\n        rows = list(reader)\n        assert rows[0] == ['id', 'name', 'email']\n        assert rows[1] == ['1', 'Alice', 'alice@example.com']\n    os.remove('test.csv')\n\ndef test_json_export():\n    data = [{'id': 2, 'name': 'Bob', 'email': 'bob@example.com'}]\n    exporter = DataExporter(data)\n    result = exporter.export('json', 'test.json')\n    assert 'test.json' in result\n    \n    with open('test.json', 'r') as f:\n        exported_data = json.load(f)\n        assert exported_data == data\n    os.remove('test.json')\n\ndef test_xml_export():\n    data = [{'id': 3, 'name': 'Charlie', 'email': 'charlie@example.com'}]\n    exporter = DataExporter(data)\n    \n    # 测试XML导出（如果实现）\n    try:\n        result = exporter.export('xml', 'test.xml')\n        assert 'test.xml' in result\n        \n        with open('test.xml', 'r') as f:\n            content = f.read()\n            assert '<user>' in content or '<id>3</id>' in content\n        os.remove('test.xml')\n    except Exception as e:\n        # 如果没有实现XML导出，应该抛出明确的异常\n        assert 'Unsupported format' in str(e) or 'not implemented' in str(e)\n\ndef test_unsupported_format():\n    data = [{'id': 1, 'name': 'Test', 'email': 'test@example.com'}]\n    exporter = DataExporter(data)\n    \n    with pytest.raises(Exception) as exc_info:\n        exporter.export('yaml', 'test.yaml')\n    \n    assert 'Unsupported' in str(exc_info.value) or 'not supported' in str(exc_info.value)\n\nif __name__ == '__main__':\n    pytest.main(['-v'])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "当前代码中，DataExporter类直接实现了具体的导出方法（export_csv, export_json），没有提供统一的扩展接口。当需要添加新的导出格式（如XML）时，必须修改DataExporter类本身，违反了开闭原则。应该通过抽象基类或策略模式来封装导出逻辑，使新的导出格式可以通过扩展而非修改来添加。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-4.2.1-001", "vcfcst_category": {"level1": "系统架构与仓库级协同失效", "level2": "仓库拓扑与多文件协同失效", "level3_id": "4.2.1", "level3_name": "目录结构与规范破坏", "defect_desc": "文件路径命名不符合仓库规范"}, "difficulty": "Easy", "case_type": "modify", "requirement": "项目要求所有数据文件必须放在 data/ 目录下，且文件名只能包含小写字母、数字和下划线。请检查并修复当前项目中不符合此规范的文件路径。", "initial_code": {"src/data_loader.py": "import os\n\ndef load_data(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n    with open(file_path, 'r') as f:\n        return f.read()\n\n# 示例用法\nif __name__ == \"__main__\":\n    data = load_data(\"Data/raw-data.csv\")\n    print(f\"Loaded {len(data)} characters\")", "config/settings.yaml": "data_sources:\n  - \"data/processed/2024_data.json\"\n  - \"Data/Raw/input.TXT\"\n  - \"data/valid_file.csv\"", "scripts/process.py": "from src.data_loader import load_data\nimport yaml\nimport os\n\ndef process_all_data():\n    with open('config/settings.yaml', 'r') as f:\n        config = yaml.safe_load(f)\n    \n    for file_path in config['data_sources']:\n        try:\n            content = load_data(file_path)\n            print(f\"Successfully processed: {file_path}\")\n        except Exception as e:\n            print(f\"Failed to process {file_path}: {e}\")\n\nif __name__ == \"__main__\":\n    process_all_data()"}, "acceptance_criteria": {"test_code": {"tests/test_file_structure.py": "import os\nimport pytest\nimport yaml\nfrom src.data_loader import load_data\n\ndef test_file_naming_convention():\n    \"\"\"测试所有数据文件路径是否符合命名规范\"\"\"\n    with open('config/settings.yaml', 'r') as f:\n        config = yaml.safe_load(f)\n    \n    violations = []\n    for file_path in config['data_sources']:\n        # 检查是否在 data/ 目录下\n        if not file_path.startswith('data/'):\n            violations.append(f\"{file_path}: 不在 data/ 目录下\")\n            continue\n        \n        # 获取文件名（不含路径）\n        filename = os.path.basename(file_path)\n        \n        # 检查文件名是否只包含小写字母、数字、下划线和点\n        import re\n        if not re.match(r'^[a-z0-9_.]+$', filename):\n            violations.append(f\"{file_path}: 文件名包含非法字符\")\n        \n        # 检查扩展名前是否有大写字母\n        name_without_ext = os.path.splitext(filename)[0]\n        if not name_without_ext.islower() and '_' not in name_without_ext:\n            violations.append(f\"{file_path}: 文件名部分包含大写字母\")\n    \n    assert len(violations) == 0, f\"发现违反命名规范的文件:\\n\" + \"\\n\".join(violations)\n\ndef test_files_exist():\n    \"\"\"测试配置中所有文件是否实际存在\"\"\"\n    with open('config/settings.yaml', 'r') as f:\n        config = yaml.safe_load(f)\n    \n    missing_files = []\n    for file_path in config['data_sources']:\n        if not os.path.exists(file_path):\n            missing_files.append(file_path)\n    \n    assert len(missing_files) == 0, f\"以下文件不存在:\\n\" + \"\\n\".join(missing_files)\n\ndef test_data_loader_integration():\n    \"\"\"测试数据加载器能正常加载所有文件\"\"\"\n    with open('config/settings.yaml', 'r') as f:\n        config = yaml.safe_load(f)\n    \n    failed_loads = []\n    for file_path in config['data_sources']:\n        try:\n            content = load_data(file_path)\n            # 简单验证内容非空\n            assert len(content) > 0, f\"{file_path} 内容为空\"\n        except Exception as e:\n            failed_loads.append(f\"{file_path}: {str(e)}\")\n    \n    assert len(failed_loads) == 0, f\"文件加载失败:\\n\" + \"\\n\".join(failed_loads)"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "初始代码中存在不符合命名规范的文件路径：1. \"Data/raw-data.csv\"（目录名大写，文件名包含连字符） 2. \"Data/Raw/input.TXT\"（目录名大写，扩展名大写）。需要修改为符合 data/ 目录下、只包含小写字母数字下划线的规范路径。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0", "pyyaml==6.0.1"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-4.2.2-001", "vcfcst_category": {"level1": "系统架构与仓库级协同失效", "level2": "仓库拓扑与多文件协同失效", "level3_id": "4.2.2", "level3_name": "多文件修改一致性失效", "defect_desc": "多文件修改遗漏导致不一致"}, "difficulty": "Medium", "case_type": "modify", "requirement": "实现一个简单的用户权限管理系统。系统包含两个文件：user_manager.py 存储用户信息，role_manager.py 存储角色权限信息。当删除一个用户时，需要同时从用户列表和角色权限列表中移除该用户的所有记录，确保数据一致性。", "initial_code": {"src/user_manager.py": "class UserManager:\n    def __init__(self):\n        self.users = {'alice': 'admin', 'bob': 'editor', 'charlie': 'viewer'}\n    \n    def delete_user(self, username):\n        if username in self.users:\n            del self.users[username]\n            return True\n        return False\n    \n    def list_users(self):\n        return list(self.users.keys())", "src/role_manager.py": "class RoleManager:\n    def __init__(self):\n        self.user_roles = {\n            'alice': ['create', 'delete', 'edit'],\n            'bob': ['edit', 'view'],\n            'charlie': ['view']\n        }\n    \n    def remove_user_roles(self, username):\n        if username in self.user_roles:\n            del self.user_roles[username]\n            return True\n        return False\n    \n    def list_users_with_roles(self):\n        return list(self.user_roles.keys())", "main.py": "from src.user_manager import UserManager\nfrom src.role_manager import RoleManager\n\ndef delete_user_system(username):\n    user_mgr = UserManager()\n    role_mgr = RoleManager()\n    \n    # 删除用户\n    user_deleted = user_mgr.delete_user(username)\n    \n    # 需要同时删除角色信息\n    # TODO: 实现角色信息的同步删除\n    \n    return user_deleted\n\nif __name__ == '__main__':\n    import sys\n    if len(sys.argv) > 1:\n        username = sys.argv[1]\n        result = delete_user_system(username)\n        print(f\"删除用户 {username}: {'成功' if result else '失败'}\")"}, "acceptance_criteria": {"test_code": {"tests/test_consistency.py": "import sys\nimport os\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))\n\nfrom src.user_manager import UserManager\nfrom src.role_manager import RoleManager\nfrom main import delete_user_system\n\ndef test_user_deletion_consistency():\n    \"\"\"测试删除用户时用户管理和角色管理的一致性\"\"\"\n    \n    # 测试1: 删除存在的用户\n    username = 'bob'\n    result = delete_user_system(username)\n    \n    # 检查用户是否从UserManager中删除\n    user_mgr = UserManager()\n    users_after_deletion = user_mgr.list_users()\n    \n    # 检查用户是否从RoleManager中删除\n    role_mgr = RoleManager()\n    roles_after_deletion = role_mgr.list_users_with_roles()\n    \n    # 断言：用户应该从两个管理器中都被删除\n    assert username not in users_after_deletion, f\"用户 {username} 应该从UserManager中删除\"\n    assert username not in roles_after_deletion, f\"用户 {username} 应该从RoleManager中删除\"\n    assert result == True, \"删除操作应该返回成功\"\n    \n    # 测试2: 删除不存在的用户\n    result = delete_user_system('nonexistent')\n    assert result == False, \"删除不存在的用户应该返回失败\"\n    \n    # 测试3: 验证其他用户不受影响\n    user_mgr = UserManager()\n    role_mgr = RoleManager()\n    \n    remaining_users = user_mgr.list_users()\n    remaining_roles = role_mgr.list_users_with_roles()\n    \n    # 检查alice和charlie是否还在两个系统中\n    assert 'alice' in remaining_users, \"alice应该还在UserManager中\"\n    assert 'alice' in remaining_roles, \"alice应该还在RoleManager中\"\n    assert 'charlie' in remaining_users, \"charlie应该还在UserManager中\"\n    assert 'charlie' in remaining_roles, \"charlie应该还在RoleManager中\"\n    \n    # 测试4: 验证两个系统的用户列表完全一致\n    assert set(remaining_users) == set(remaining_roles), \"UserManager和RoleManager中的用户列表应该完全一致\"\n\ndef test_initial_state():\n    \"\"\"测试初始状态\"\"\"\n    user_mgr = UserManager()\n    role_mgr = RoleManager()\n    \n    initial_users = user_mgr.list_users()\n    initial_roles = role_mgr.list_users_with_roles()\n    \n    assert set(initial_users) == {'alice', 'bob', 'charlie'}, \"初始用户列表应该包含alice, bob, charlie\"\n    assert set(initial_roles) == {'alice', 'bob', 'charlie'}, \"初始角色列表应该包含alice, bob, charlie\"\n    assert set(initial_users) == set(initial_roles), \"初始状态下两个系统的用户列表应该一致\"\n\nif __name__ == '__main__':\n    test_initial_state()\n    print(\"初始状态测试通过\")\n    \n    test_user_deletion_consistency()\n    print(\"一致性测试通过\")"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者可能在实现delete_user_system函数时，只调用了UserManager的delete_user方法，但忘记调用RoleManager的remove_user_roles方法，导致用户从用户列表中被删除，但在角色权限列表中仍然存在，造成数据不一致。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-4.2.3-001", "vcfcst_category": {"level1": "系统架构与仓库级协同失效", "level2": "仓库拓扑与多文件协同失效", "level3_id": "4.2.3", "level3_name": "模块间依赖冲突", "defect_desc": "破坏依赖规则导致循环依赖"}, "difficulty": "Medium", "case_type": "modify", "requirement": "现有三个模块：订单处理模块(order_processor)、库存管理模块(inventory_manager)和支付网关模块(payment_gateway)。订单处理需要检查库存并调用支付，库存管理需要记录支付后的库存变更。请根据业务逻辑完善模块间的依赖关系，确保功能正常。", "initial_code": {"src/order_processor.py": "from src.inventory_manager import InventoryManager\n\nclass OrderProcessor:\n    def __init__(self):\n        self.inventory = InventoryManager()\n    \n    def process_order(self, product_id, quantity):\n        if self.inventory.check_stock(product_id, quantity):\n            # 这里需要调用支付功能\n            return \"Order processed successfully\"\n        return \"Insufficient stock\"", "src/inventory_manager.py": "from src.payment_gateway import PaymentGateway\n\nclass InventoryManager:\n    def __init__(self):\n        self.payment = PaymentGateway()\n    \n    def check_stock(self, product_id, quantity):\n        # 模拟库存检查\n        stock = {\"A001\": 10, \"B002\": 5}\n        return stock.get(product_id, 0) >= quantity\n    \n    def update_stock(self, product_id, quantity):\n        # 支付成功后更新库存\n        print(f\"Stock updated: {product_id} reduced by {quantity}\")", "src/payment_gateway.py": "from src.order_processor import OrderProcessor\n\nclass PaymentGateway:\n    def __init__(self):\n        self.order_processor = OrderProcessor()\n    \n    def process_payment(self, amount):\n        # 模拟支付处理\n        print(f\"Processing payment of ${amount}\")\n        return True\n    \n    def refund_payment(self, order_id):\n        # 退款时需要通知订单模块\n        return self.order_processor.cancel_order(order_id)"}, "acceptance_criteria": {"test_code": {"tests/test_modules.py": "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../src')))\n\nimport pytest\n\ndef test_module_imports():\n    \"\"\"测试模块能否正常导入\"\"\"\n    try:\n        from src.order_processor import OrderProcessor\n        from src.inventory_manager import InventoryManager\n        from src.payment_gateway import PaymentGateway\n        assert True\n    except ImportError as e:\n        pytest.fail(f\"Import failed: {e}\")\n    except Exception as e:\n        pytest.fail(f\"Unexpected error: {e}\")\n\ndef test_circular_dependency_detection():\n    \"\"\"检测循环依赖\"\"\"\n    import src.order_processor\n    import src.inventory_manager\n    import src.payment_gateway\n    \n    # 尝试创建实例，循环依赖会导致递归错误\n    try:\n        order = src.order_processor.OrderProcessor()\n        inventory = src.inventory_manager.InventoryManager()\n        payment = src.payment_gateway.PaymentGateway()\n        \n        # 如果执行到这里，检查是否真的有循环\n        if hasattr(order, 'inventory') and hasattr(inventory, 'payment') and hasattr(payment, 'order_processor'):\n            # 验证依赖链\n            assert order.inventory is not None\n            assert inventory.payment is not None\n            assert payment.order_processor is not None\n            \n            # 关键断言：检查是否形成循环\n            # 如果payment.order_processor.inventory.payment存在，则形成循环\n            chain_exists = hasattr(payment.order_processor, 'inventory') and \\\n                          hasattr(payment.order_processor.inventory, 'payment')\n            \n            # 有循环依赖则测试失败\n            assert not chain_exists, \"Circular dependency detected: PaymentGateway -> OrderProcessor -> InventoryManager -> PaymentGateway\"\n            \n    except RecursionError:\n        pytest.fail(\"RecursionError detected - circular dependency exists\")\n    except Exception as e:\n        # 其他异常可能是代码错误，但不是循环依赖\n        pass\n\ndef test_business_logic():\n    \"\"\"测试基本业务逻辑（如果无循环依赖）\"\"\"\n    try:\n        from src.order_processor import OrderProcessor\n        from src.inventory_manager import InventoryManager\n        \n        order = OrderProcessor()\n        result = order.process_order(\"A001\", 2)\n        assert result in [\"Order processed successfully\", \"Insufficient stock\"]\n        \n        inventory = InventoryManager()\n        assert inventory.check_stock(\"A001\", 2) == True\n        assert inventory.check_stock(\"B002\", 10) == False\n        \n    except RecursionError:\n        pytest.fail(\"Business logic test failed due to circular dependency\")\n    except Exception as e:\n        # 允许其他错误，重点检测循环依赖\n        pass"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "当前代码存在循环依赖：OrderProcessor 依赖 InventoryManager，InventoryManager 依赖 PaymentGateway，PaymentGateway 又依赖 OrderProcessor，形成 OrderProcessor -> InventoryManager -> PaymentGateway -> OrderProcessor 的循环链。这会导致导入时递归错误或运行时不可预测行为。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-4.2.4-001", "vcfcst_category": {"level1": "系统架构与仓库级协同失效", "level2": "仓库拓扑与多文件协同失效", "level3_id": "4.2.4", "level3_name": "全局配置污染", "defect_desc": "错误修改全局配置导致冲突"}, "difficulty": "Medium", "case_type": "modify", "requirement": "项目中有多个模块需要读取数据库配置。请修改代码，让所有模块都能正确获取数据库连接配置。当前发现某些模块读取配置时出现异常。", "initial_code": {"config/db_config.py": "import json\n\nclass DBConfig:\n    _config = {\n        'host': 'localhost',\n        'port': 3306,\n        'database': 'default_db'\n    }\n    \n    @classmethod\n    def get_config(cls):\n        return cls._config.copy()\n    \n    @classmethod\n    def update_config(cls, new_config):\n        cls._config.update(new_config)", "modules/user_module.py": "from config.db_config import DBConfig\n\nclass UserModule:\n    def __init__(self):\n        config = DBConfig.get_config()\n        self.host = config['host']\n        self.port = config['port']\n        self.database = config['database']\n    \n    def get_connection_string(self):\n        return f\"mysql://{self.host}:{self.port}/{self.database}\"", "modules/order_module.py": "from config.db_config import DBConfig\n\nclass OrderModule:\n    def __init__(self):\n        config = DBConfig._config  # 直接访问内部属性\n        self.host = config['host']\n        self.port = config['port']\n        self.database = config['database']\n    \n    def get_connection_string(self):\n        return f\"mysql://{self.host}:{self.port}/{self.database}\"", "main.py": "from config.db_config import DBConfig\nfrom modules.user_module import UserModule\nfrom modules.order_module import OrderModule\n\n# 模拟配置更新\nDBConfig.update_config({'database': 'production_db'})\n\n# 创建模块实例\nuser_module = UserModule()\norder_module = OrderModule()\n\nprint(f\"User module connection: {user_module.get_connection_string()}\")\nprint(f\"Order module connection: {order_module.get_connection_string()}\")"}, "acceptance_criteria": {"test_code": {"tests/test_db_config.py": "import pytest\nfrom config.db_config import DBConfig\nfrom modules.user_module import UserModule\nfrom modules.order_module import OrderModule\n\nclass TestDBConfig:\n    def test_config_isolation(self):\n        \"\"\"测试配置修改不会相互污染\"\"\"\n        # 初始配置\n        DBConfig._config = {'host': 'localhost', 'port': 3306, 'database': 'test_db'}\n        \n        # 创建第一个模块实例\n        user1 = UserModule()\n        assert user1.get_connection_string() == \"mysql://localhost:3306/test_db\"\n        \n        # 修改配置\n        DBConfig.update_config({'database': 'updated_db'})\n        \n        # 创建第二个模块实例\n        user2 = UserModule()\n        order1 = OrderModule()\n        \n        # 验证第一个实例的配置不应被修改\n        assert user1.get_connection_string() == \"mysql://localhost:3306/test_db\"\n        # 验证新实例使用新配置\n        assert user2.get_connection_string() == \"mysql://localhost:3306/updated_db\"\n        assert order1.get_connection_string() == \"mysql://localhost:3306/updated_db\"\n    \n    def test_direct_access_protection(self):\n        \"\"\"测试直接访问内部配置属性的保护\"\"\"\n        DBConfig._config = {'host': 'server1', 'port': 3306, 'database': 'db1'}\n        \n        # 通过get_config获取配置副本\n        config_copy = DBConfig.get_config()\n        config_copy['database'] = 'modified_db'\n        \n        # 修改副本不应影响原始配置\n        assert DBConfig._config['database'] == 'db1'\n        \n        # 直接修改内部配置应该被正确同步\n        DBConfig._config['database'] = 'direct_modified'\n        order_module = OrderModule()\n        assert order_module.database == 'direct_modified'\n\nif __name__ == '__main__':\n    pytest.main(['-v', __file__])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "OrderModule直接访问DBConfig._config内部属性，导致配置修改时产生全局污染。当配置更新后，已创建的UserModule实例应该保持原有配置，但OrderModule的访问方式使得所有实例都共享同一配置对象，破坏了配置隔离性。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-4.3.1-001", "vcfcst_category": {"level1": "系统架构与仓库级协同失效", "level2": "分布式与跨系统协同失效", "level3_id": "4.3.1", "level3_name": "分布式一致性失效", "defect_desc": "跨服务一致性控制缺失"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个简单的在线书店订单系统。系统包含两个服务：库存服务（InventoryService）和订单服务（OrderService）。当用户下单购买一本书时，订单服务需要调用库存服务来扣减库存。请实现下单逻辑，确保库存扣减和订单创建要么都成功，要么都失败。当前代码中两个服务的调用是独立的，没有一致性保证。", "initial_code": {"services/inventory_service.py": "class InventoryService:\n    def __init__(self):\n        self.stock = {'book1': 10, 'book2': 5}\n\n    def reduce_stock(self, book_id, quantity):\n        if book_id in self.stock and self.stock[book_id] >= quantity:\n            self.stock[book_id] -= quantity\n            return True\n        return False\n\n    def get_stock(self, book_id):\n        return self.stock.get(book_id, 0)", "services/order_service.py": "from services.inventory_service import InventoryService\n\n\nclass OrderService:\n    def __init__(self):\n        self.inventory_service = InventoryService()\n        self.orders = []\n\n    def create_order(self, order_id, book_id, quantity):\n        # TODO: 实现下单逻辑，需要保证库存扣减和订单创建的一致性\n        # 当前实现存在分布式一致性问题\n        success = self.inventory_service.reduce_stock(book_id, quantity)\n        if success:\n            self.orders.append({'order_id': order_id, 'book_id': book_id, 'quantity': quantity})\n            return True\n        return False\n\n    def get_order_count(self):\n        return len(self.orders)", "main.py": "from services.order_service import OrderService\n\nif __name__ == '__main__':\n    order_service = OrderService()\n    # 模拟下单\n    result = order_service.create_order('order1', 'book1', 2)\n    print(f'下单结果: {result}')\n    print(f'订单数量: {order_service.get_order_count()}')\n    print(f'book1库存: {order_service.inventory_service.get_stock(\"book1\")}')"}, "acceptance_criteria": {"test_code": {"tests/test_order_system.py": "import pytest\nfrom services.order_service import OrderService\nfrom services.inventory_service import InventoryService\n\n\ndef test_order_creation_success():\n    \"\"\"测试正常下单\"\"\"\n    order_service = OrderService()\n    initial_stock = order_service.inventory_service.get_stock('book1')\n    \n    result = order_service.create_order('order1', 'book1', 2)\n    \n    assert result is True\n    assert order_service.get_order_count() == 1\n    assert order_service.inventory_service.get_stock('book1') == initial_stock - 2\n\n\ndef test_order_creation_insufficient_stock():\n    \"\"\"测试库存不足时下单\"\"\"\n    order_service = OrderService()\n    initial_stock = order_service.inventory_service.get_stock('book2')\n    \n    result = order_service.create_order('order2', 'book2', 10)\n    \n    assert result is False\n    assert order_service.get_order_count() == 0\n    assert order_service.inventory_service.get_stock('book2') == initial_stock\n\n\ndef test_order_creation_consistency_failure():\n    \"\"\"测试分布式一致性失效场景\"\"\"\n    # 模拟库存服务调用成功但订单创建失败的情况\n    order_service = OrderService()\n    initial_stock = order_service.inventory_service.get_stock('book1')\n    \n    # 先直接调用库存服务扣减\n    inventory_success = order_service.inventory_service.reduce_stock('book1', 1)\n    assert inventory_success is True\n    \n    # 然后模拟订单创建失败（例如网络异常、服务崩溃等）\n    # 这里我们通过不调用create_order来模拟\n    \n    # 验证一致性失效：库存已扣减但订单未创建\n    assert order_service.inventory_service.get_stock('book1') == initial_stock - 1\n    assert order_service.get_order_count() == 0\n    \n    # 这个测试应该通过，因为当前实现确实存在一致性问题\n    # 修复后的实现应该让这个测试失败（即不会出现这种不一致状态）\n\n\ndef test_concurrent_orders():\n    \"\"\"测试并发下单\"\"\"\n    order_service = OrderService()\n    initial_stock = order_service.inventory_service.get_stock('book1')\n    \n    # 模拟两个并发下单请求\n    result1 = order_service.create_order('order1', 'book1', 3)\n    result2 = order_service.create_order('order2', 'book1', 4)\n    \n    # 根据实现，可能两个都成功（如果没做并发控制）\n    # 但库存应该足够支持至少一个订单\n    total_ordered = 0\n    if result1:\n        total_ordered += 3\n    if result2:\n        total_ordered += 4\n    \n    assert order_service.inventory_service.get_stock('book1') == initial_stock - total_ordered\n    assert order_service.get_order_count() == (1 if result1 else 0) + (1 if result2 else 0)\n\n\nif __name__ == '__main__':\n    pytest.main(['-v', __file__])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "当前实现中，库存扣减和订单创建是两个独立的操作，没有分布式事务或补偿机制。如果库存扣减成功但订单创建失败（或反之），会导致数据不一致：库存减少了但订单没创建，或者订单创建了但库存没减少。这体现了'跨服务一致性控制缺失'的缺陷。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-4.3.2-001", "vcfcst_category": {"level1": "系统架构与仓库级协同失效", "level2": "分布式与跨系统协同失效", "level3_id": "4.3.2", "level3_name": "跨服务通信失效", "defect_desc": "超时重试/熔断等通信逻辑缺失"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个简单的商品库存查询服务。该服务需要调用一个外部的库存微服务API来获取商品库存信息。外部API地址为：http://inventory-service:8080/api/inventory/{product_id}。请实现一个函数，接收商品ID，返回该商品的库存数量。注意：外部服务可能偶尔出现网络延迟或暂时不可用的情况。", "initial_code": {"inventory_client.py": "import requests\n\nclass InventoryClient:\n    def __init__(self, base_url='http://inventory-service:8080'):\n        self.base_url = base_url\n    \n    def get_inventory(self, product_id: str) -> int:\n        \"\"\"\n        根据商品ID查询库存数量\n        Args:\n            product_id: 商品ID\n        Returns:\n            库存数量，如果查询失败返回-1\n        \"\"\"\n        # TODO: 实现库存查询逻辑\n        # 需要调用外部API: {base_url}/api/inventory/{product_id}\n        # API返回JSON格式: {\"product_id\": \"xxx\", \"stock\": 100}\n        pass\n\n# 使用示例\nif __name__ == \"__main__\":\n    client = InventoryClient()\n    print(client.get_inventory(\"P001\"))"}, "acceptance_criteria": {"test_code": {"tests/test_inventory_client.py": "import pytest\nimport time\nfrom unittest.mock import Mock, patch\nfrom inventory_client import InventoryClient\n\nclass MockResponse:\n    def __init__(self, status_code, json_data=None):\n        self.status_code = status_code\n        self.json_data = json_data\n    \n    def json(self):\n        return self.json_data\n\ndef test_normal_response():\n    \"\"\"测试正常响应\"\"\"\n    with patch('inventory_client.requests.get') as mock_get:\n        mock_get.return_value = MockResponse(200, {\"product_id\": \"P001\", \"stock\": 100})\n        client = InventoryClient(base_url='http://mock-service')\n        result = client.get_inventory(\"P001\")\n        assert result == 100\n\ndef test_slow_response():\n    \"\"\"测试慢响应（超过2秒）\"\"\"\n    def slow_get(*args, **kwargs):\n        time.sleep(3)  # 模拟慢响应\n        return MockResponse(200, {\"product_id\": \"P001\", \"stock\": 100})\n    \n    with patch('inventory_client.requests.get', side_effect=slow_get):\n        client = InventoryClient(base_url='http://mock-service')\n        start_time = time.time()\n        result = client.get_inventory(\"P001\")\n        end_time = time.time()\n        \n        # 如果没有超时设置，执行时间会超过2秒\n        # 如果有超时设置，应该在2秒内返回\n        assert end_time - start_time < 2.5, \"请求应该设置超时时间\"\n\ndef test_service_unavailable():\n    \"\"\"测试服务不可用（返回500错误）\"\"\"\n    with patch('inventory_client.requests.get') as mock_get:\n        mock_get.return_value = MockResponse(500, None)\n        client = InventoryClient(base_url='http://mock-service')\n        result = client.get_inventory(\"P001\")\n        # 如果没有重试或熔断逻辑，可能直接返回-1\n        # 测试会检查是否有适当的错误处理\n\ndef test_network_timeout():\n    \"\"\"测试网络超时\"\"\"\n    def timeout_get(*args, **kwargs):\n        raise requests.exceptions.Timeout()\n    \n    with patch('inventory_client.requests.get', side_effect=timeout_get):\n        client = InventoryClient(base_url='http://mock-service')\n        result = client.get_inventory(\"P001\")\n        # 检查是否有超时处理逻辑\n\ndef test_retry_logic():\n    \"\"\"测试重试逻辑（如果实现）\"\"\"\n    call_count = 0\n    \n    def failing_then_succeed(*args, **kwargs):\n        nonlocal call_count\n        call_count += 1\n        if call_count < 3:\n            raise requests.exceptions.ConnectionError()\n        return MockResponse(200, {\"product_id\": \"P001\", \"stock\": 100})\n    \n    with patch('inventory_client.requests.get', side_effect=failing_then_succeed):\n        client = InventoryClient(base_url='http://mock-service')\n        result = client.get_inventory(\"P001\")\n        \n        # 如果有重试逻辑，call_count应该大于1\n        # 如果没有重试逻辑，可能在第一次失败后就返回了\n        print(f\"API调用次数: {call_count}\")\n\ndef test_circuit_breaker():\n    \"\"\"测试熔断器逻辑（如果实现）\"\"\"\n    # 连续模拟多次失败\n    with patch('inventory_client.requests.get') as mock_get:\n        mock_get.side_effect = requests.exceptions.ConnectionError()\n        client = InventoryClient(base_url='http://mock-service')\n        \n        results = []\n        for i in range(5):\n            try:\n                result = client.get_inventory(f\"P{i:03d}\")\n                results.append(result)\n            except Exception as e:\n                results.append(str(e))\n        \n        # 检查是否有熔断模式：连续失败后是否快速失败或降级\n        print(f\"连续调用结果: {results}\")\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\"])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "实现中缺少对跨服务通信的容错处理，包括：1) 没有设置请求超时时间；2) 没有实现重试机制应对临时性故障；3) 没有熔断器模式防止级联故障；4) 没有降级策略。这会导致当外部库存服务出现延迟或故障时，本服务会长时间阻塞或直接失败。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0", "requests==2.31.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-4.3.3-001", "vcfcst_category": {"level1": "系统架构与仓库级协同失效", "level2": "分布式与跨系统协同失效", "level3_id": "4.3.3", "level3_name": "跨技术栈适配失效", "defect_desc": "跨栈接口或字段命名不匹配"}, "difficulty": "Medium", "case_type": "modify", "requirement": "现有Python服务需要调用一个由Go语言实现的用户积分查询服务。Python服务中定义了UserCredit类，包含用户ID和积分余额字段。Go服务返回的JSON数据字段命名风格不同。请修改Python服务中的数据处理逻辑，确保能正确解析Go服务返回的用户积分数据。", "initial_code": {"services/credit_client.py": "import requests\nimport json\n\nclass UserCredit:\n    def __init__(self, user_id: str, credit_balance: float):\n        self.user_id = user_id\n        self.credit_balance = credit_balance\n\nclass CreditServiceClient:\n    def __init__(self, base_url: str):\n        self.base_url = base_url\n    \n    def get_user_credit(self, user_id: str) -> UserCredit:\n        \"\"\"调用Go服务获取用户积分\"\"\"\n        response = requests.get(f\"{self.base_url}/api/v1/user-credit/{user_id}\")\n        response.raise_for_status()\n        \n        # 当前实现假设Go服务返回的字段名与Python类完全一致\n        data = response.json()\n        return UserCredit(\n            user_id=data['user_id'],\n            credit_balance=data['credit_balance']\n        )"}, "acceptance_criteria": {"test_code": {"tests/test_credit_client.py": "import pytest\nfrom services.credit_client import CreditServiceClient, UserCredit\n\nclass MockGoService:\n    \"\"\"模拟Go服务的响应数据，使用Go风格的字段命名\"\"\"\n    @staticmethod\n    def get_mock_response():\n        # Go服务实际返回的JSON（使用驼峰命名）\n        return {\n            \"userId\": \"usr_123456\",\n            \"creditBalance\": 1500.75\n        }\n\nclass TestCreditServiceClient:\n    def test_parse_go_service_response(self):\n        \"\"\"测试能否正确解析Go服务返回的数据\"\"\"\n        client = CreditServiceClient(\"http://mock-go-service\")\n        \n        # 模拟requests.get返回Go风格的响应\n        mock_response = type('obj', (object,), {\n            'json': lambda: MockGoService.get_mock_response(),\n            'raise_for_status': lambda: None\n        })()\n        \n        # 替换requests.get\n        import services.credit_client\n        original_get = services.credit_client.requests.get\n        services.credit_client.requests.get = lambda url, **kwargs: mock_response\n        \n        try:\n            result = client.get_user_credit(\"usr_123456\")\n            \n            # 验证解析结果\n            assert isinstance(result, UserCredit)\n            assert result.user_id == \"usr_123456\"\n            assert result.credit_balance == 1500.75\n            \n            # 验证字段映射正确\n            assert hasattr(result, 'user_id')\n            assert hasattr(result, 'credit_balance')\n        finally:\n            services.credit_client.requests.get = original_get\n    \n    def test_user_credit_initialization(self):\n        \"\"\"测试UserCredit类的基本功能\"\"\"\n        credit = UserCredit(\"test_user\", 1000.0)\n        assert credit.user_id == \"test_user\"\n        assert credit.credit_balance == 1000.0\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\"])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "Python服务使用蛇形命名（user_id, credit_balance），而Go服务返回驼峰命名（userId, creditBalance），导致JSON解析时KeyError异常。需要修改CreditServiceClient.get_user_credit方法，正确处理跨技术栈的字段命名差异。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0", "requests==2.31.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-5.1.1-001", "vcfcst_category": {"level1": "安全与合规性失效", "level2": "高危安全漏洞", "level3_id": "5.1.1", "level3_name": "注入类漏洞", "defect_desc": "输入未过滤导致注入漏洞"}, "difficulty": "Medium", "case_type": "modify", "requirement": "实现一个简单的用户评论系统，允许用户提交评论并查看历史评论。评论数据存储在SQLite数据库中。需要修复代码中的安全漏洞，确保用户输入被正确处理，防止恶意注入攻击。", "initial_code": {"app/database.py": "import sqlite3\n\ndef init_db():\n    conn = sqlite3.connect('comments.db')\n    cursor = conn.cursor()\n    cursor.execute('''CREATE TABLE IF NOT EXISTS comments\n                     (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                      username TEXT NOT NULL,\n                      content TEXT NOT NULL,\n                      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')\n    conn.commit()\n    conn.close()\n\ndef add_comment(username, content):\n    conn = sqlite3.connect('comments.db')\n    cursor = conn.cursor()\n    query = f\"INSERT INTO comments (username, content) VALUES ('{username}', '{content}')\"\n    cursor.execute(query)\n    conn.commit()\n    conn.close()\n\ndef get_comments():\n    conn = sqlite3.connect('comments.db')\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT username, content, created_at FROM comments ORDER BY created_at DESC\")\n    results = cursor.fetchall()\n    conn.close()\n    return results", "app/main.py": "from database import init_db, add_comment, get_comments\n\ninit_db()\n\nprint(\"评论系统\")\nprint(\"1. 添加评论\")\nprint(\"2. 查看评论\")\n\nwhile True:\n    choice = input(\"请选择操作 (1/2): \")\n    if choice == '1':\n        username = input(\"用户名: \")\n        content = input(\"评论内容: \")\n        add_comment(username, content)\n        print(\"评论已添加！\\n\")\n    elif choice == '2':\n        comments = get_comments()\n        if comments:\n            for username, content, created_at in comments:\n                print(f\"[{created_at}] {username}: {content}\")\n        else:\n            print(\"暂无评论\")\n        print()\n    else:\n        print(\"无效选择\\n\")"}, "acceptance_criteria": {"test_code": {"tests/test_injection.py": "import pytest\nimport sqlite3\nimport os\nfrom app.database import add_comment, get_comments, init_db\n\n@pytest.fixture(autouse=True)\ndef setup_teardown():\n    if os.path.exists('comments.db'):\n        os.remove('comments.db')\n    init_db()\n    yield\n    if os.path.exists('comments.db'):\n        os.remove('comments.db')\n\ndef test_normal_comment():\n    add_comment('user1', '正常评论内容')\n    comments = get_comments()\n    assert len(comments) == 1\n    assert comments[0][0] == 'user1'\n    assert comments[0][1] == '正常评论内容'\n\ndef test_sql_injection_attack():\n    malicious_content = \"test'); DROP TABLE comments; --\"\n    add_comment('attacker', malicious_content)\n    comments = get_comments()\n    assert len(comments) == 1\n    assert comments[0][0] == 'attacker'\n    assert comments[0][1] == malicious_content\n    conn = sqlite3.connect('comments.db')\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='comments'\")\n    tables = cursor.fetchall()\n    conn.close()\n    assert len(tables) == 1\n    assert tables[0][0] == 'comments'\n\ndef test_xss_injection_attempt():\n    xss_content = \"<script>alert('xss')</script>\"\n    add_comment('user2', xss_content)\n    comments = get_comments()\n    assert len(comments) == 1\n    assert comments[0][1] == xss_content\n\ndef test_union_injection():\n    union_content = \"' UNION SELECT username, password FROM users --\"\n    add_comment('hacker', union_content)\n    comments = get_comments()\n    assert len(comments) == 1\n    assert comments[0][1] == union_content\n\ndef test_multiple_comments():\n    test_data = [\n        ('alice', '第一条评论'),\n        ('bob', \"第二条'特殊评论\"),\n        ('charlie', \"第三条;复杂评论\")\n    ]\n    for username, content in test_data:\n        add_comment(username, content)\n    comments = get_comments()\n    assert len(comments) == 3\n    for i, (username, content, _) in enumerate(comments):\n        assert username == test_data[2-i][0]\n        assert content == test_data[2-i][1]"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "初始代码中使用字符串拼接直接构造SQL查询语句，存在SQL注入漏洞。攻击者可以通过输入特殊字符（如单引号、分号等）来修改SQL语句逻辑，可能导致数据泄露、数据篡改或数据库破坏。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-5.1.2-001", "vcfcst_category": {"level1": "安全与合规性失效", "level2": "高危安全漏洞", "level3_id": "5.1.2", "level3_name": "权限与访问控制缺陷", "defect_desc": "权限校验缺失导致越权"}, "difficulty": "Medium", "case_type": "modify", "requirement": "实现一个简单的文档管理系统，用户可以查看、编辑和删除自己的文档。系统需要确保用户只能操作自己拥有的文档，不能访问或修改其他用户的文档。请修复现有代码中的权限控制缺陷。", "initial_code": {"app/document_manager.py": "import json\n\nclass DocumentManager:\n    def __init__(self):\n        self.documents = {}\n    \n    def add_document(self, user_id, doc_id, content):\n        if doc_id not in self.documents:\n            self.documents[doc_id] = {\n                'owner': user_id,\n                'content': content\n            }\n            return True\n        return False\n    \n    def get_document(self, user_id, doc_id):\n        if doc_id in self.documents:\n            return self.documents[doc_id]['content']\n        return None\n    \n    def update_document(self, user_id, doc_id, new_content):\n        if doc_id in self.documents:\n            self.documents[doc_id]['content'] = new_content\n            return True\n        return False\n    \n    def delete_document(self, user_id, doc_id):\n        if doc_id in self.documents:\n            del self.documents[doc_id]\n            return True\n        return False\n\n# 使用示例\nif __name__ == '__main__':\n    dm = DocumentManager()\n    dm.add_document('user1', 'doc1', 'User1 private content')\n    dm.add_document('user2', 'doc2', 'User2 private content')\n    \n    # 测试：user1 尝试访问 user2 的文档\n    content = dm.get_document('user1', 'doc2')\n    print(f\"User1 accessing User2's document: {content}\")\n    \n    # 测试：user1 尝试修改 user2 的文档\n    success = dm.update_document('user1', 'doc2', 'Hacked content')\n    print(f\"User1 modifying User2's document: {success}\")"}, "acceptance_criteria": {"test_code": {"tests/test_document_manager.py": "import pytest\nfrom app.document_manager import DocumentManager\n\n@pytest.fixture\ndef setup_manager():\n    dm = DocumentManager()\n    dm.add_document('user1', 'doc1', 'User1 private content')\n    dm.add_document('user2', 'doc2', 'User2 private content')\n    dm.add_document('user3', 'doc3', 'User3 private content')\n    return dm\n\ndef test_owner_can_access_own_document(setup_manager):\n    dm = setup_manager\n    content = dm.get_document('user1', 'doc1')\n    assert content == 'User1 private content'\n\ndef test_owner_can_update_own_document(setup_manager):\n    dm = setup_manager\n    success = dm.update_document('user2', 'doc2', 'Updated content')\n    assert success is True\n    content = dm.get_document('user2', 'doc2')\n    assert content == 'Updated content'\n\ndef test_owner_can_delete_own_document(setup_manager):\n    dm = setup_manager\n    success = dm.delete_document('user3', 'doc3')\n    assert success is True\n    content = dm.get_document('user3', 'doc3')\n    assert content is None\n\ndef test_user_cannot_access_others_document(setup_manager):\n    dm = setup_manager\n    content = dm.get_document('user1', 'doc2')\n    assert content is None\n\ndef test_user_cannot_update_others_document(setup_manager):\n    dm = setup_manager\n    success = dm.update_document('user1', 'doc2', 'Hacked content')\n    assert success is False\n    content = dm.get_document('user2', 'doc2')\n    assert content == 'User2 private content'\n\ndef test_user_cannot_delete_others_document(setup_manager):\n    dm = setup_manager\n    success = dm.delete_document('user2', 'doc1')\n    assert success is False\n    content = dm.get_document('user1', 'doc1')\n    assert content == 'User1 private content'\n\ndef test_nonexistent_document(setup_manager):\n    dm = setup_manager\n    content = dm.get_document('user1', 'nonexistent')\n    assert content is None\n    success = dm.update_document('user1', 'nonexistent', 'content')\n    assert success is False\n    success = dm.delete_document('user1', 'nonexistent')\n    assert success is False\n\nif __name__ == '__main__':\n    pytest.main(['-v'])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "现有代码在 get_document、update_document 和 delete_document 方法中缺少权限校验，任何用户都可以通过提供文档ID来访问、修改或删除其他用户的文档，存在严重的越权访问漏洞。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-5.1.3-001", "vcfcst_category": {"level1": "安全与合规性失效", "level2": "高危安全漏洞", "level3_id": "5.1.3", "level3_name": "敏感数据保护失效", "defect_desc": "敏感数据明文或无保护"}, "difficulty": "Medium", "case_type": "modify", "requirement": "开发一个用户健康档案管理系统，需要存储用户的健康数据。系统需要提供添加健康记录和查询健康记录的功能。健康记录包含用户ID、记录时间、血压值、血糖值和诊断备注。请确保敏感的健康数据在存储和传输过程中得到适当保护。", "initial_code": {"health_record.py": "class HealthRecord:\n    def __init__(self, user_id, record_time, blood_pressure, blood_sugar, diagnosis_note):\n        self.user_id = user_id\n        self.record_time = record_time\n        self.blood_pressure = blood_pressure\n        self.blood_sugar = blood_sugar\n        self.diagnosis_note = diagnosis_note\n\n    def to_dict(self):\n        return {\n            'user_id': self.user_id,\n            'record_time': self.record_time,\n            'blood_pressure': self.blood_pressure,\n            'blood_sugar': self.blood_sugar,\n            'diagnosis_note': self.diagnosis_note\n        }\n\n\nclass HealthRecordManager:\n    def __init__(self):\n        self.records = []\n\n    def add_record(self, record):\n        \"\"\"添加健康记录\"\"\"\n        self.records.append(record)\n        return len(self.records)\n\n    def get_record_by_user(self, user_id):\n        \"\"\"根据用户ID查询健康记录\"\"\"\n        user_records = []\n        for record in self.records:\n            if record.user_id == user_id:\n                user_records.append(record.to_dict())\n        return user_records\n\n    def get_all_records(self):\n        \"\"\"获取所有健康记录（用于管理目的）\"\"\"\n        return [record.to_dict() for record in self.records]"}, "acceptance_criteria": {"test_code": {"tests/test_health_record.py": "import pytest\nfrom health_record import HealthRecord, HealthRecordManager\n\n\ndef test_sensitive_data_protection():\n    \"\"\"测试敏感数据是否得到保护\"\"\"\n    manager = HealthRecordManager()\n    \n    # 添加测试数据\n    test_record = HealthRecord(\n        user_id='user123',\n        record_time='2024-01-15 10:30:00',\n        blood_pressure='120/80',\n        blood_sugar='5.6',\n        diagnosis_note='Patient shows normal vital signs'\n    )\n    manager.add_record(test_record)\n    \n    # 测试1：检查存储的数据是否明文\n    all_records = manager.get_all_records()\n    assert len(all_records) == 1\n    \n    record_data = all_records[0]\n    \n    # 敏感数据（血压、血糖）不应以明文形式存储\n    # 如果数据是明文，测试将失败\n    blood_pressure = record_data['blood_pressure']\n    blood_sugar = record_data['blood_sugar']\n    \n    # 检查是否为明文（简单的格式检查）\n    # 血压通常包含'/'，血糖是数字格式\n    # 如果这些值以原始形式存在，说明没有保护\n    is_plaintext = False\n    \n    # 检查血压格式（明文通常为'120/80'格式）\n    if '/' in str(blood_pressure) and any(c.isdigit() for c in str(blood_pressure)):\n        is_plaintext = True\n    \n    # 检查血糖格式（明文通常为数字或带单位的数字）\n    if isinstance(blood_sugar, (int, float)) or \\\n       (isinstance(blood_sugar, str) and blood_sugar.replace('.', '').isdigit()):\n        is_plaintext = True\n    \n    # 如果发现明文敏感数据，测试失败\n    assert not is_plaintext, \"敏感数据（血压、血糖）应以加密或脱敏形式存储，不应为明文\"\n    \n    # 测试2：检查数据传输是否保护\n    user_records = manager.get_record_by_user('user123')\n    assert len(user_records) == 1\n    \n    user_record_data = user_records[0]\n    \n    # 同样检查返回的数据是否保护\n    bp_in_response = user_record_data['blood_pressure']\n    bs_in_response = user_record_data['blood_sugar']\n    \n    response_is_plaintext = False\n    \n    if '/' in str(bp_in_response) and any(c.isdigit() for c in str(bp_in_response)):\n        response_is_plaintext = True\n    \n    if isinstance(bs_in_response, (int, float)) or \\\n       (isinstance(bs_in_response, str) and bs_in_response.replace('.', '').isdigit()):\n        response_is_plaintext = True\n    \n    assert not response_is_plaintext, \"敏感数据在传输/返回时应得到保护\"\n    \n    # 测试3：验证非敏感数据可正常访问\n    assert user_record_data['user_id'] == 'user123'\n    assert user_record_data['record_time'] == '2024-01-15 10:30:00'\n    assert 'diagnosis' in user_record_data['diagnosis_note'].lower() or \\\n           'patient' in user_record_data['diagnosis_note'].lower()\n\n\ndef test_record_functionality():\n    \"\"\"测试基本功能正常\"\"\"\n    manager = HealthRecordManager()\n    \n    record1 = HealthRecord('user1', '2024-01-15 10:00:00', '130/85', '6.1', 'Slight hypertension')\n    record2 = HealthRecord('user2', '2024-01-15 11:00:00', '115/75', '5.2', 'Normal')\n    \n    manager.add_record(record1)\n    manager.add_record(record2)\n    \n    assert len(manager.get_all_records()) == 2\n    assert len(manager.get_record_by_user('user1')) == 1\n    assert len(manager.get_record_by_user('user2')) == 1\n    assert len(manager.get_record_by_user('user3')) == 0\n\n\nif __name__ == '__main__':\n    pytest.main(['-v', 'tests/test_health_record.py'])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "健康档案管理系统中的敏感数据（血压、血糖值）以明文形式存储和传输，没有进行任何加密、脱敏或保护措施，违反了敏感数据保护要求。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-5.1.4-001", "vcfcst_category": {"level1": "安全与合规性失效", "level2": "高危安全漏洞", "level3_id": "5.1.4", "level3_name": "其他高危安全缺陷", "defect_desc": "路径遍历/反序列化/SSRF等高危漏洞"}, "difficulty": "Medium", "case_type": "modify", "requirement": "实现一个简单的文件预览功能，用户可以通过文件名参数请求查看指定文件的预览内容。请确保功能安全可靠，防止恶意访问系统文件。", "initial_code": {"app/file_preview.py": "import os\n\nclass FilePreview:\n    def __init__(self, base_dir='./uploads'):\n        self.base_dir = base_dir\n        \n    def get_preview(self, filename):\n        \"\"\"返回指定文件的前100个字符作为预览\"\"\"\n        filepath = os.path.join(self.base_dir, filename)\n        \n        try:\n            with open(filepath, 'r', encoding='utf-8') as f:\n                content = f.read(100)\n            return {\n                'status': 'success',\n                'preview': content,\n                'filename': filename\n            }\n        except Exception as e:\n            return {\n                'status': 'error',\n                'message': str(e)\n            }\n\n# 使用示例\nif __name__ == '__main__':\n    previewer = FilePreview()\n    result = previewer.get_preview('document.txt')\n    print(result)"}, "acceptance_criteria": {"test_code": {"tests/test_file_preview.py": "import os\nimport sys\nimport tempfile\nimport pytest\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))\n\nfrom app.file_preview import FilePreview\n\n@pytest.fixture\ndef setup_test_env():\n    \"\"\"创建测试环境和文件\"\"\"\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # 创建uploads目录\n        uploads_dir = os.path.join(tmpdir, 'uploads')\n        os.makedirs(uploads_dir, exist_ok=True)\n        \n        # 创建合法文件\n        legal_file = os.path.join(uploads_dir, 'legal.txt')\n        with open(legal_file, 'w') as f:\n            f.write('This is a legal file content.' * 10)\n        \n        # 创建敏感文件\n        sensitive_file = os.path.join(tmpdir, 'sensitive.txt')\n        with open(sensitive_file, 'w') as f:\n            f.write('SECRET_PASSWORD=admin123')\n        \n        # 创建系统文件模拟\n        etc_file = '/etc/passwd'\n        \n        yield {\n            'tmpdir': tmpdir,\n            'uploads_dir': uploads_dir,\n            'legal_file': legal_file,\n            'sensitive_file': sensitive_file,\n            'etc_file': etc_file\n        }\n\nclass TestFilePreview:\n    def test_normal_file_access(self, setup_test_env):\n        \"\"\"测试正常文件访问\"\"\"\n        previewer = FilePreview(base_dir=setup_test_env['uploads_dir'])\n        result = previewer.get_preview('legal.txt')\n        assert result['status'] == 'success'\n        assert 'preview' in result\n        assert len(result['preview']) <= 100\n    \n    def test_path_traversal_attack(self, setup_test_env):\n        \"\"\"测试路径遍历攻击防护\"\"\"\n        previewer = FilePreview(base_dir=setup_test_env['uploads_dir'])\n        \n        # 测试相对路径遍历\n        result1 = previewer.get_preview('../sensitive.txt')\n        \n        # 测试绝对路径遍历\n        result2 = previewer.get_preview('/etc/passwd')\n        \n        # 测试嵌套路径遍历\n        result3 = previewer.get_preview('../../../etc/passwd')\n        \n        # 测试空字节注入\n        result4 = previewer.get_preview('legal.txt\\x00../sensitive.txt')\n        \n        # 测试URL编码绕过\n        result5 = previewer.get_preview('%2e%2e%2fsensitive.txt')\n        \n        # 所有攻击尝试都应该失败\n        attacks = [result1, result2, result3, result4, result5]\n        for attack_result in attacks:\n            # 应该返回错误或无法访问敏感内容\n            if attack_result['status'] == 'success':\n                # 如果成功，检查是否真的访问到了敏感文件\n                preview_content = attack_result.get('preview', '')\n                assert 'SECRET_PASSWORD' not in preview_content\n                assert 'root:' not in preview_content\n    \n    def test_file_not_found(self, setup_test_env):\n        \"\"\"测试文件不存在的情况\"\"\"\n        previewer = FilePreview(base_dir=setup_test_env['uploads_dir'])\n        result = previewer.get_preview('nonexistent.txt')\n        assert result['status'] == 'error'\n    \n    def test_directory_traversal(self, setup_test_env):\n        \"\"\"测试目录遍历攻击\"\"\"\n        previewer = FilePreview(base_dir=setup_test_env['uploads_dir'])\n        \n        # 尝试访问目录\n        result = previewer.get_preview('.')\n        # 应该返回错误或空内容\n        if result['status'] == 'success':\n            assert result['preview'] == ''\n        \n    def test_null_byte_injection(self, setup_test_env):\n        \"\"\"测试空字节注入攻击\"\"\"\n        previewer = FilePreview(base_dir=setup_test_env['uploads_dir'])\n        \n        # 创建包含空字节的文件名\n        malicious_file = os.path.join(setup_test_env['uploads_dir'], 'test\\x00.txt')\n        with open(malicious_file.replace('\\x00', ''), 'w') as f:\n            f.write('test')\n            \n        result = previewer.get_preview('test\\x00.txt')\n        # 应该正确处理或返回错误\n        assert result['status'] in ['success', 'error']\n\nif __name__ == '__main__':\n    pytest.main(['-v', __file__])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "代码存在路径遍历漏洞，攻击者可以通过构造恶意文件名（如'../sensitive.txt'、'/etc/passwd'、'../../../etc/passwd'等）访问系统任意文件，导致敏感信息泄露。需要添加路径规范化检查和目录限制。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-5.3.1-001", "vcfcst_category": {"level1": "安全与合规性失效", "level2": "合规性失效", "level3_id": "5.3.1", "level3_name": "数据合规失效", "defect_desc": "违反个人信息保护等法规"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个用户健康档案查询接口。该接口接收用户ID，返回该用户的健康档案信息（包括姓名、年龄、疾病史、用药记录）。要求：1. 仅当请求方提供了有效的授权令牌（token）且该token对应的用户ID与请求查询的用户ID一致时，才允许查询。2. 如果请求查询的用户ID与token中的用户ID不一致，应返回错误，禁止查询他人健康信息。3. 健康档案信息为敏感个人信息，必须严格保护。", "initial_code": {"app/api.py": "from flask import Flask, request, jsonify\nimport json\nimport os\n\napp = Flask(__name__)\n\n# 模拟的健康档案数据库\nHEALTH_RECORDS = {\n    \"user_001\": {\"name\": \"张三\", \"age\": 35, \"disease_history\": [\"高血压\"], \"medication\": [\"降压药\"]},\n    \"user_002\": {\"name\": \"李四\", \"age\": 28, \"disease_history\": [\"糖尿病\"], \"medication\": [\"胰岛素\"]},\n    \"user_003\": {\"name\": \"王五\", \"age\": 45, \"disease_history\": [], \"medication\": []}\n}\n\n# 模拟的令牌验证函数（已实现）\ndef verify_token(token):\n    \"\"\"验证令牌，返回令牌对应的用户ID，若无效则返回None\"\"\"\n    # 简单模拟：token格式为 \"token_<user_id>\"\n    if token and token.startswith(\"token_\") and token[6:] in HEALTH_RECORDS:\n        return token[6:]\n    return None\n\n# TODO: 实现以下接口\n@app.route('/health_record/<user_id>', methods=['GET'])\ndef get_health_record(user_id):\n    \"\"\"\n    查询指定用户的健康档案。\n    请求头需包含：Authorization: Bearer <token>\n    仅当token中的用户ID与请求的user_id一致时才返回数据。\n    \"\"\"\n    # 你的代码写在这里\n    pass\n\nif __name__ == '__main__':\n    app.run(debug=True)"}, "acceptance_criteria": {"test_code": {"tests/test_api.py": "import pytest\nimport sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom app.api import app\n\n@pytest.fixture\ndef client():\n    app.config['TESTING'] = True\n    with app.test_client() as client:\n        yield client\n\ndef test_get_own_health_record_success(client):\n    \"\"\"测试：用户使用自己的token查询自己的健康档案，应该成功\"\"\"\n    headers = {'Authorization': 'Bearer token_user_001'}\n    response = client.get('/health_record/user_001', headers=headers)\n    assert response.status_code == 200\n    data = response.get_json()\n    assert data['name'] == '张三'\n    assert 'disease_history' in data\n\ndef test_get_others_health_record_forbidden(client):\n    \"\"\"测试：用户使用自己的token查询他人的健康档案，应该被拒绝（数据合规失效缺陷）\"\"\"\n    headers = {'Authorization': 'Bearer token_user_001'}\n    response = client.get('/health_record/user_002', headers=headers)\n    # 如果接口实现正确，应该返回403或401等错误状态码，表示禁止访问\n    # 如果接口存在缺陷（允许查询），则此断言会失败\n    assert response.status_code != 200  # 不应成功\n    assert response.status_code in [403, 401, 400]  # 应该是某种错误状态\n\ndef test_invalid_token(client):\n    \"\"\"测试：使用无效token查询，应该被拒绝\"\"\"\n    headers = {'Authorization': 'Bearer invalid_token'}\n    response = client.get('/health_record/user_001', headers=headers)\n    assert response.status_code != 200\n    assert response.status_code in [401, 403]\n\ndef test_missing_token(client):\n    \"\"\"测试：没有提供token，应该被拒绝\"\"\"\n    response = client.get('/health_record/user_001')\n    assert response.status_code != 200\n    assert response.status_code in [401, 403]\n\ndef test_token_user_not_exist(client):\n    \"\"\"测试：token有效但查询的用户ID不存在，应该返回404\"\"\"\n    headers = {'Authorization': 'Bearer token_user_001'}\n    response = client.get('/health_record/non_existent_user', headers=headers)\n    # 用户不存在，应返回404\n    assert response.status_code == 404\n\nif __name__ == '__main__':\n    pytest.main()"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者可能未严格校验请求查询的用户ID与令牌中用户ID的一致性，导致用户可以使用自己的令牌查询他人的敏感健康信息（疾病史、用药记录等），这违反了个人信息保护法规中关于最小必要和授权同意的原则，构成数据合规失效。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0", "Flask==2.3.3"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-5.3.2-001", "vcfcst_category": {"level1": "安全与合规性失效", "level2": "合规性失效", "level3_id": "5.3.2", "level3_name": "行业规范违背", "defect_desc": "违反行业强制合规标准"}, "difficulty": "Medium", "case_type": "implement", "requirement": "实现一个函数，用于验证用户输入的密码是否符合金融行业密码安全规范。具体要求如下：1. 密码长度必须至少为12个字符；2. 必须包含至少一个大写字母；3. 必须包含至少一个小写字母；4. 必须包含至少一个数字；5. 必须包含至少一个特殊字符（!@#$%^&*）；6. 不能包含连续三个相同的字符（如'aaa'）；7. 不能包含常见的弱密码模式（如'password123'、'qwerty'）。函数应返回一个布尔值，True表示密码合规，False表示不合规。", "initial_code": {"src/password_validator.py": "def validate_password(password: str) -> bool:\n    \"\"\"\n    验证密码是否符合金融行业安全规范。\n    \n    Args:\n        password (str): 待验证的密码字符串\n        \n    Returns:\n        bool: True表示密码合规，False表示不合规\n    \"\"\"\n    # TODO: 实现密码验证逻辑\n    return True"}, "acceptance_criteria": {"test_code": {"tests/test_password_validator.py": "import pytest\nfrom src.password_validator import validate_password\n\nclass TestPasswordValidator:\n    def test_valid_password(self):\n        \"\"\"测试合规密码\"\"\"\n        assert validate_password(\"StrongP@ss123!\") == True\n        assert validate_password(\"Secure#Pass456\") == True\n        assert validate_password(\"Valid!Pass789\") == True\n    \n    def test_too_short(self):\n        \"\"\"测试密码长度不足\"\"\"\n        assert validate_password(\"Short1!\") == False\n        assert validate_password(\"Ab1!\") == False\n    \n    def test_missing_uppercase(self):\n        \"\"\"测试缺少大写字母\"\"\"\n        assert validate_password(\"lowercase123!\") == False\n        assert validate_password(\"alllower123#\") == False\n    \n    def test_missing_lowercase(self):\n        \"\"\"测试缺少小写字母\"\"\"\n        assert validate_password(\"UPPERCASE123!\") == False\n        assert validate_password(\"ALLUPPER456#\") == False\n    \n    def test_missing_digit(self):\n        \"\"\"测试缺少数字\"\"\"\n        assert validate_password(\"NoDigitPass!\") == False\n        assert validate_password(\"PasswordOnly#\") == False\n    \n    def test_missing_special_char(self):\n        \"\"\"测试缺少特殊字符\"\"\"\n        assert validate_password(\"NoSpecial123\") == False\n        assert validate_password(\"Password1234\") == False\n    \n    def test_repeated_chars(self):\n        \"\"\"测试连续重复字符\"\"\"\n        assert validate_password(\"Pass111word!\") == False\n        assert validate_password(\"AAAbbb123#!\") == False\n        assert validate_password(\"Test@@@123\") == False\n    \n    def test_weak_patterns(self):\n        \"\"\"测试弱密码模式\"\"\"\n        assert validate_password(\"password123!\") == False\n        assert validate_password(\"qwerty123#\") == False\n        assert validate_password(\"1234567890aA!\") == False\n        assert validate_password(\"admin123!\") == False\n    \n    def test_edge_cases(self):\n        \"\"\"测试边界情况\"\"\"\n        assert validate_password(\"A1b!A1b!A1b!\") == True  # 刚好12字符\n        assert validate_password(\"A1b!A1b!A1b!A1b!\") == True  # 更长密码\n        assert validate_password(\"A1b!A1b!A1b\") == False  # 11字符\n        assert validate_password(\"\") == False  # 空密码\n        assert validate_password(\" \") == False  # 空格\n        \n    def test_special_char_boundary(self):\n        \"\"\"测试特殊字符边界\"\"\"\n        # 允许的特殊字符\n        assert validate_password(\"Test!123456\") == True\n        assert validate_password(\"Test@123456\") == True\n        assert validate_password(\"Test#123456\") == True\n        assert validate_password(\"Test$123456\") == True\n        assert validate_password(\"Test%123456\") == True\n        assert validate_password(\"Test^123456\") == True\n        assert validate_password(\"Test&123456\") == True\n        assert validate_password(\"Test*123456\") == True\n        \n        # 不允许的特殊字符\n        assert validate_password(\"Test-123456\") == False\n        assert validate_password(\"Test_123456\") == False\n        assert validate_password(\"Test+123456\") == False\n        \n    def test_unicode_and_whitespace(self):\n        \"\"\"测试Unicode和空白字符\"\"\"\n        assert validate_password(\"Pass123!\\t\") == False  # 包含制表符\n        assert validate_password(\"Pass123!\\n\") == False  # 包含换行符\n        assert validate_password(\"Pass123!\\r\") == False  # 包含回车符\n        assert validate_password(\"Pass123!\\x00\") == False  # 包含空字符\n        \n    def test_common_weak_passwords(self):\n        \"\"\"测试常见弱密码\"\"\"\n        weak_passwords = [\n            \"password\",\n            \"123456\",\n            \"qwerty\",\n            \"letmein\",\n            \"welcome\",\n            \"monkey\",\n            \"dragon\",\n            \"baseball\",\n            \"football\",\n            \"mustang\",\n            \"master\",\n            \"superman\",\n            \"harley\",\n            \"ranger\",\n            \"jordan\",\n            \"yamaha\",\n            \"ninja\",\n            \"chelsea\",\n            \"united\",\n            \"ferrari\"\n        ]\n        \n        for weak in weak_passwords:\n            # 即使添加了必要的字符，基础模式仍然是弱的\n            modified = weak.capitalize() + \"123!\"\n            if len(modified) >= 12:\n                assert validate_password(modified) == False, f\"弱密码变体应该被拒绝: {modified}\""}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者可能忽略金融行业的强制合规标准，例如：1. 未检查密码长度至少12个字符；2. 未要求必须包含特殊字符；3. 未禁止连续重复字符；4. 未检测常见的弱密码模式；5. 允许使用不符合行业规范的特殊字符集。这些缺陷会导致系统接受不符合金融行业安全标准的密码，违反行业强制合规要求。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-5.3.3-001", "vcfcst_category": {"level1": "安全与合规性失效", "level2": "合规性失效", "level3_id": "5.3.3", "level3_name": "开源协议合规失效", "defect_desc": "违反开源协议导致侵权风险"}, "difficulty": "Medium", "case_type": "modify", "requirement": "开发一个简单的图像处理工具，需要实现图片格式转换功能。用户要求能够将PNG图片转换为JPG格式，并且保留基本的图像质量。请实现这个转换功能，并确保工具可以处理常见的图片尺寸。", "initial_code": {"image_converter.py": "import sys\n\ndef convert_png_to_jpg(input_path, output_path):\n    \"\"\"\n    将PNG图片转换为JPG格式\n    \n    参数:\n        input_path: 输入PNG文件路径\n        output_path: 输出JPG文件路径\n    \n    返回:\n        bool: 转换是否成功\n    \"\"\"\n    try:\n        # 这里需要实现图片转换逻辑\n        # 当前实现使用了Pillow库\n        from PIL import Image\n        \n        img = Image.open(input_path)\n        if img.mode in ('RGBA', 'LA'):\n            # 创建白色背景\n            background = Image.new('RGB', img.size, (255, 255, 255))\n            if img.mode == 'RGBA':\n                background.paste(img, mask=img.split()[3])\n            else:\n                background.paste(img, mask=img.split()[1])\n            img = background\n        \n        img.save(output_path, 'JPEG', quality=95)\n        return True\n    except Exception as e:\n        print(f\"转换失败: {e}\", file=sys.stderr)\n        return False\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 3:\n        print(\"用法: python image_converter.py <输入PNG文件> <输出JPG文件>\")\n        sys.exit(1)\n    \n    success = convert_png_to_jpg(sys.argv[1], sys.argv[2])\n    if success:\n        print(\"转换成功\")\n    else:\n        print(\"转换失败\")\n        sys.exit(1)"}, "acceptance_criteria": {"test_code": {"tests/test_converter.py": "import pytest\nimport os\nimport tempfile\nfrom PIL import Image\nimport numpy as np\n\n# 测试图片创建辅助函数\ndef create_test_png(filename, size=(100, 100), rgba=False):\n    \"\"\"创建测试PNG图片\"\"\"\n    if rgba:\n        img = Image.new('RGBA', size, (255, 0, 0, 255))\n    else:\n        img = Image.new('RGB', size, (255, 0, 0))\n    img.save(filename, 'PNG')\n    return filename\n\ndef test_convert_png_to_jpg_basic():\n    \"\"\"测试基本PNG转JPG功能\"\"\"\n    from image_converter import convert_png_to_jpg\n    \n    with tempfile.TemporaryDirectory() as tmpdir:\n        input_png = os.path.join(tmpdir, 'test.png')\n        output_jpg = os.path.join(tmpdir, 'test.jpg')\n        \n        # 创建测试PNG\n        create_test_png(input_png)\n        \n        # 执行转换\n        result = convert_png_to_jpg(input_png, output_jpg)\n        \n        # 验证结果\n        assert result == True, \"转换应该成功\"\n        assert os.path.exists(output_jpg), \"输出文件应该存在\"\n        \n        # 验证输出文件格式\n        img = Image.open(output_jpg)\n        assert img.format == 'JPEG', \"输出文件应该是JPEG格式\"\n\ndef test_convert_png_to_jpg_rgba():\n    \"\"\"测试RGBA PNG转JPG功能\"\"\"\n    from image_converter import convert_png_to_jpg\n    \n    with tempfile.TemporaryDirectory() as tmpdir:\n        input_png = os.path.join(tmpdir, 'test_rgba.png')\n        output_jpg = os.path.join(tmpdir, 'test_rgba.jpg')\n        \n        # 创建RGBA测试PNG\n        create_test_png(input_png, rgba=True)\n        \n        # 执行转换\n        result = convert_png_to_jpg(input_png, output_jpg)\n        \n        # 验证结果\n        assert result == True, \"RGBA转换应该成功\"\n        assert os.path.exists(output_jpg), \"输出文件应该存在\"\n        \n        # 验证输出文件格式和模式\n        img = Image.open(output_jpg)\n        assert img.format == 'JPEG', \"输出文件应该是JPEG格式\"\n        assert img.mode == 'RGB', \"输出应该是RGB模式\"\n\ndef test_convert_png_to_jpg_invalid_input():\n    \"\"\"测试无效输入处理\"\"\"\n    from image_converter import convert_png_to_jpg\n    \n    with tempfile.TemporaryDirectory() as tmpdir:\n        output_jpg = os.path.join(tmpdir, 'test.jpg')\n        \n        # 测试不存在的文件\n        result = convert_png_to_jpg('nonexistent.png', output_jpg)\n        assert result == False, \"不存在的文件应该转换失败\"\n\ndef test_license_compliance():\n    \"\"\"测试开源协议合规性\"\"\"\n    import image_converter\n    \n    # 检查是否使用了GPL协议的库\n    # Pillow是HPND协议，但这里测试的是是否存在GPL协议违规\n    \n    # 检查导入的模块\n    import inspect\n    source = inspect.getsource(image_converter.convert_png_to_jpg)\n    \n    # 关键检查：代码中是否包含了GPL协议的库\n    # 这里检查是否使用了pygame（GPL协议）或类似的GPL库\n    gpl_keywords = ['pygame', 'GPL', 'General Public License']\n    \n    for keyword in gpl_keywords:\n        assert keyword.lower() not in source.lower(), \\\n            f\"代码中不应该使用GPL协议的库: {keyword}\"\n    \n    # 检查依赖声明\n    # 这是一个静态检查，确保没有隐藏的GPL依赖\n    assert True, \"协议合规性检查通过\"\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, '-v'])"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "初始代码中使用了Pillow库（HPND协议），但开发者可能会错误地引入GPL协议的图像处理库（如pygame）来实现功能，导致开源协议冲突。测试用例会检查代码中是否包含GPL相关库的使用，确保没有违反开源协议。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0", "pillow==10.0.0", "numpy==1.24.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-6.1.1-001", "vcfcst_category": {"level1": "工程化迭代与技术债务失效", "level2": "迭代中的错误级联失效", "level3_id": "6.1.1", "level3_name": "错误修复的次生灾害", "defect_desc": "修复引入新逻辑错误"}, "difficulty": "Medium", "case_type": "modify", "requirement": "用户反馈：当购物车中有多个相同商品时，计算总价有时会出错。请修复calculate_total_price函数，确保它能正确处理商品数量大于1的情况。", "initial_code": {"cart.py": "def calculate_total_price(items):\n    \"\"\"计算购物车总价\n    \n    Args:\n        items: 商品列表，每个元素为(商品单价, 数量)\n    \n    Returns:\n        总价格\n    \"\"\"\n    total = 0\n    for price, quantity in items:\n        if quantity > 0:\n            total += price * quantity\n    return total\n\n\ndef apply_discount(total, discount_rate):\n    \"\"\"应用折扣\n    \n    Args:\n        total: 原总价\n        discount_rate: 折扣率(0-1之间的小数)\n    \n    Returns:\n        折后价格\n    \"\"\"\n    if 0 <= discount_rate <= 1:\n        return total * (1 - discount_rate)\n    return total\n\n\ndef calculate_final_price(items, discount_rate=0):\n    \"\"\"计算最终价格（含折扣）\n    \n    Args:\n        items: 商品列表\n        discount_rate: 折扣率\n    \n    Returns:\n        最终价格\n    \"\"\"\n    total = calculate_total_price(items)\n    return apply_discount(total, discount_rate)"}, "acceptance_criteria": {"test_code": {"tests/test_cart.py": "import pytest\nfrom cart import calculate_total_price, apply_discount, calculate_final_price\n\n\ndef test_calculate_total_price_basic():\n    \"\"\"测试基本价格计算\"\"\"\n    items = [(10.0, 2), (5.0, 1)]\n    assert calculate_total_price(items) == 25.0\n\n\ndef test_calculate_total_price_zero_quantity():\n    \"\"\"测试数量为0的商品\"\"\"\n    items = [(10.0, 0), (5.0, 3)]\n    assert calculate_total_price(items) == 15.0\n\n\ndef test_calculate_total_price_negative_quantity():\n    \"\"\"测试数量为负的商品\"\"\"\n    items = [(10.0, -1), (5.0, 2)]\n    assert calculate_total_price(items) == 10.0\n\n\ndef test_calculate_total_price_empty():\n    \"\"\"测试空购物车\"\"\"\n    assert calculate_total_price([]) == 0.0\n\n\ndef test_calculate_total_price_single_item():\n    \"\"\"测试单个商品\"\"\"\n    items = [(15.5, 1)]\n    assert calculate_total_price(items) == 15.5\n\n\ndef test_calculate_total_price_multiple_same_items():\n    \"\"\"测试多个相同商品\"\"\"\n    items = [(8.0, 3), (8.0, 2)]  # 用户反馈的问题场景\n    assert calculate_total_price(items) == 40.0\n\n\ndef test_apply_discount_normal():\n    \"\"\"测试正常折扣\"\"\"\n    assert apply_discount(100, 0.1) == 90.0\n    assert apply_discount(100, 0.2) == 80.0\n\n\ndef test_apply_discount_edge_cases():\n    \"\"\"测试边界折扣\"\"\"\n    assert apply_discount(100, 0) == 100.0\n    assert apply_discount(100, 1) == 0.0\n    assert apply_discount(100, -0.1) == 100.0\n    assert apply_discount(100, 1.5) == 100.0\n\n\ndef test_calculate_final_price():\n    \"\"\"测试最终价格计算\"\"\"\n    items = [(10.0, 2), (5.0, 1)]\n    assert calculate_final_price(items, 0.1) == 22.5\n    assert calculate_final_price(items, 0) == 25.0\n\n\ndef test_calculate_final_price_with_multiple_same():\n    \"\"\"测试多个相同商品的最终价格\"\"\"\n    items = [(8.0, 3), (8.0, 2)]\n    assert calculate_final_price(items, 0.1) == 36.0"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者可能只修复了calculate_total_price函数中处理多个相同商品的问题，但在修复过程中可能错误地修改了数量判断逻辑（如将if quantity > 0改为if quantity >= 0），导致数量为0的商品也被计入总价，或者修改了折扣应用逻辑，导致最终价格计算错误。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-6.1.2-001", "vcfcst_category": {"level1": "工程化迭代与技术债务失效", "level2": "迭代中的错误级联失效", "level3_id": "6.1.2", "level3_name": "回归缺陷", "defect_desc": "修复导致已修复缺陷重现"}, "difficulty": "Medium", "case_type": "modify", "requirement": "用户需要一个简单的购物车系统，能够添加商品、计算总价并应用折扣。当前代码存在一个缺陷：当购物车为空时，计算总价会抛出异常。请修复这个缺陷，并确保在修复过程中不会破坏现有的折扣计算功能。", "initial_code": {"cart.py": "class ShoppingCart:\n    def __init__(self):\n        self.items = []\n        self.discount = 0.0\n\n    def add_item(self, name, price):\n        self.items.append({'name': name, 'price': price})\n\n    def set_discount(self, discount_percent):\n        if discount_percent < 0 or discount_percent > 100:\n            raise ValueError('Discount must be between 0 and 100')\n        self.discount = discount_percent / 100.0\n\n    def calculate_total(self):\n        total = sum(item['price'] for item in self.items)\n        # 这里有一个缺陷：当购物车为空时，total为0，但下面的计算会导致除以0的错误\n        discounted_total = total - (total * self.discount)\n        return discounted_total\n\n    def clear(self):\n        self.items = []\n        self.discount = 0.0"}, "acceptance_criteria": {"test_code": {"tests/test_cart.py": "import pytest\nfrom cart import ShoppingCart\n\n\ndef test_empty_cart_total():\n    cart = ShoppingCart()\n    # 修复前这里会抛出ZeroDivisionError\n    total = cart.calculate_total()\n    assert total == 0.0\n\n\ndef test_cart_with_items_no_discount():\n    cart = ShoppingCart()\n    cart.add_item('Apple', 1.5)\n    cart.add_item('Banana', 0.8)\n    total = cart.calculate_total()\n    assert total == 2.3\n\n\ndef test_cart_with_discount():\n    cart = ShoppingCart()\n    cart.add_item('Apple', 10.0)\n    cart.add_item('Banana', 5.0)\n    cart.set_discount(20.0)\n    total = cart.calculate_total()\n    assert total == 12.0  # 15 - (15 * 0.2)\n\n\ndef test_cart_empty_with_discount():\n    cart = ShoppingCart()\n    cart.set_discount(10.0)\n    total = cart.calculate_total()\n    assert total == 0.0\n\n\ndef test_discount_boundary():\n    cart = ShoppingCart()\n    cart.add_item('Item', 100.0)\n    cart.set_discount(0.0)\n    assert cart.calculate_total() == 100.0\n    \n    cart.set_discount(100.0)\n    assert cart.calculate_total() == 0.0\n\n\ndef test_invalid_discount():\n    cart = ShoppingCart()\n    with pytest.raises(ValueError):\n        cart.set_discount(-5.0)\n    with pytest.raises(ValueError):\n        cart.set_discount(150.0)"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者在修复空购物车计算总价的缺陷时，可能会错误地修改折扣计算逻辑，导致原本正确的折扣功能失效。例如，可能会将计算逻辑改为'total * (1 - self.discount)'，但当discount为0时，如果total为0，这个表达式仍然有效，但可能会忽略边界条件或引入新的错误。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-6.1.3-001", "vcfcst_category": {"level1": "工程化迭代与技术债务失效", "level2": "迭代中的错误级联失效", "level3_id": "6.1.3", "level3_name": "多轮迭代的上下文漂移", "defect_desc": "多轮后偏离初始需求"}, "difficulty": "Medium", "case_type": "modify", "requirement": "实现一个简单的购物车系统，支持添加商品、计算总价和折扣。初始需求：1. 添加商品时，如果商品已存在则增加数量；2. 总价计算为所有商品单价*数量的总和；3. 当总价超过100元时，自动应用9折优惠。后续迭代中，请根据用户反馈逐步调整功能。", "initial_code": {"cart.py": "class ShoppingCart:\n    def __init__(self):\n        self.items = {}\n\n    def add_item(self, name, price, quantity=1):\n        if name in self.items:\n            self.items[name]['quantity'] += quantity\n        else:\n            self.items[name] = {'price': price, 'quantity': quantity}\n\n    def calculate_total(self):\n        total = 0\n        for item in self.items.values():\n            total += item['price'] * item['quantity']\n        if total > 100:\n            total *= 0.9\n        return round(total, 2)\n\n    def get_items(self):\n        return self.items.copy()"}, "acceptance_criteria": {"test_code": {"tests/test_cart.py": "import pytest\nfrom cart import ShoppingCart\n\ndef test_initial_requirement():\n    cart = ShoppingCart()\n    cart.add_item('apple', 10.0, 2)\n    cart.add_item('banana', 5.0, 3)\n    # 10*2 + 5*3 = 35 < 100, no discount\n    assert cart.calculate_total() == 35.0\n    cart.add_item('laptop', 80.0, 1)\n    # 35 + 80 = 115 > 100, apply 10% discount\n    assert cart.calculate_total() == 103.5\n\ndef test_add_existing_item():\n    cart = ShoppingCart()\n    cart.add_item('apple', 10.0, 2)\n    cart.add_item('apple', 10.0, 3)\n    assert cart.get_items()['apple']['quantity'] == 5\n\ndef test_iteration_1_discount_change():\n    cart = ShoppingCart()\n    cart.add_item('item1', 60.0, 2)  # 120 total\n    # After iteration 1: discount threshold changed to 150\n    # Expected: no discount applied, total = 120\n    # This test will FAIL initially, showing context drift\n    assert cart.calculate_total() == 120.0\n\ndef test_iteration_2_new_feature():\n    cart = ShoppingCart()\n    cart.add_item('item1', 30.0, 5)  # 150 total\n    # After iteration 2: new feature - bulk discount for quantity >= 5\n    # Expected: apply 15% discount for bulk items\n    # This test will FAIL initially, showing further drift\n    assert cart.get_items()['item1']['price'] == 25.5  # 30 * 0.85\n\ndef test_iteration_3_side_effect():\n    cart = ShoppingCart()\n    cart.add_item('apple', 10.0, 2)\n    cart.add_item('banana', 5.0, 3)\n    # After iteration 3: discount logic changed to only apply to items > 50\n    # This breaks original requirement but was added for \"performance\"\n    # Expected: 35.0 (no discount)\n    # This test will FAIL initially\n    assert cart.calculate_total() == 35.0\n\ndef test_final_state():\n    cart = ShoppingCart()\n    cart.add_item('apple', 10.0, 2)\n    cart.add_item('premium', 80.0, 1)\n    cart.add_item('bulk_item', 20.0, 6)\n    # After all iterations, the system should still satisfy ORIGINAL requirement:\n    # 1. Total = 10*2 + 80 + 20*6 = 220\n    # 2. Since 220 > 100, apply 10% discount = 198\n    # But due to context drift, actual result may differ\n    assert cart.calculate_total() == 198.0"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "在多轮迭代后，购物车系统的折扣逻辑会逐渐偏离初始需求。初始需求明确：总价超过100元时统一打9折。但经过多次修改后，可能出现：1. 折扣阈值被改为150元；2. 新增了批量购买折扣；3. 折扣仅适用于高价商品。这些修改单独看可能有合理性，但整体导致系统行为与原始需求不一致，形成上下文漂移。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-6.1.4-001", "vcfcst_category": {"level1": "工程化迭代与技术债务失效", "level2": "迭代中的错误级联失效", "level3_id": "6.1.4", "level3_name": "增量修改的内容覆盖", "defect_desc": "局部改动覆盖整文件"}, "difficulty": "Medium", "case_type": "modify", "requirement": "现有用户积分计算模块，需要增加一个功能：当用户连续登录天数超过7天时，额外奖励50积分。请修改积分计算函数，确保原有积分规则（普通登录+10分，VIP登录+20分）保持不变，只添加连续登录奖励逻辑。", "initial_code": {"src/points_calculator.py": "def calculate_points(user_type, login_days):\n    \"\"\"计算用户积分\n    \n    Args:\n        user_type: 'regular' 或 'vip'\n        login_days: 连续登录天数\n    \n    Returns:\n        总积分\n    \"\"\"\n    base_points = 0\n    \n    # 基础积分计算\n    if user_type == 'regular':\n        base_points = 10\n    elif user_type == 'vip':\n        base_points = 20\n    \n    return base_points"}, "acceptance_criteria": {"test_code": {"tests/test_points_calculator.py": "import pytest\nfrom src.points_calculator import calculate_points\n\ndef test_regular_user_basic():\n    \"\"\"测试普通用户基础积分\"\"\"\n    assert calculate_points('regular', 1) == 10\n    assert calculate_points('regular', 3) == 10\n\ndef test_vip_user_basic():\n    \"\"\"测试VIP用户基础积分\"\"\"\n    assert calculate_points('vip', 1) == 20\n    assert calculate_points('vip', 5) == 20\n\ndef test_continuous_login_reward():\n    \"\"\"测试连续登录奖励\"\"\"\n    # 连续登录不足7天，无额外奖励\n    assert calculate_points('regular', 6) == 10\n    assert calculate_points('vip', 6) == 20\n    \n    # 连续登录7天，有额外奖励\n    assert calculate_points('regular', 7) == 60  # 10 + 50\n    assert calculate_points('vip', 7) == 70     # 20 + 50\n    \n    # 连续登录超过7天\n    assert calculate_points('regular', 10) == 60\n    assert calculate_points('vip', 15) == 70\n\ndef test_invalid_user_type():\n    \"\"\"测试无效用户类型\"\"\"\n    # 原有逻辑应保持不变\n    assert calculate_points('invalid', 1) == 0\n    assert calculate_points('', 7) == 0"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者可能直接重写整个函数，而不是在原有逻辑基础上增量修改，导致原有的用户类型验证逻辑被覆盖或删除，使得无效用户类型测试失败。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
{"case_id": "VCFCST-6.1.5-001", "vcfcst_category": {"level1": "工程化迭代与技术债务失效", "level2": "迭代中的错误级联失效", "level3_id": "6.1.5", "level3_name": "重构失效", "defect_desc": "重构破坏逻辑或契约"}, "difficulty": "Medium", "case_type": "modify", "requirement": "现有代码实现了一个简单的购物车折扣计算功能。在重构过程中，需要将原来的折扣计算逻辑从Cart类中提取到独立的DiscountCalculator类中，以遵循单一职责原则。请完成这次重构，确保重构后的代码行为与原始代码完全一致。注意：不要改变原有的公共接口和计算规则。", "initial_code": {"cart.py": "class Cart:\n    def __init__(self):\n        self.items = []\n    \n    def add_item(self, name, price, quantity=1):\n        self.items.append({\n            'name': name,\n            'price': price,\n            'quantity': quantity\n        })\n    \n    def calculate_total(self):\n        total = 0\n        for item in self.items:\n            total += item['price'] * item['quantity']\n        \n        # 折扣计算逻辑\n        if total > 1000:\n            total = total * 0.9  # 满1000打9折\n        elif total > 500:\n            total = total * 0.95  # 满500打95折\n        \n        # 会员额外折扣\n        if len(self.items) >= 3:\n            total = total * 0.98  # 购买3件以上商品额外98折\n        \n        return round(total, 2)\n    \n    def clear(self):\n        self.items = []"}, "acceptance_criteria": {"test_code": {"tests/test_cart.py": "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom cart import Cart\n\ndef test_empty_cart():\n    cart = Cart()\n    assert cart.calculate_total() == 0\n\ndef test_single_item():\n    cart = Cart()\n    cart.add_item('Book', 100)\n    assert cart.calculate_total() == 100\n\ndef test_multiple_items():\n    cart = Cart()\n    cart.add_item('Book', 100, 2)\n    cart.add_item('Pen', 10, 5)\n    # 100*2 + 10*5 = 250\n    # 满500以下无折扣\n    assert cart.calculate_total() == 250\n\ndef test_volume_discount():\n    cart = Cart()\n    cart.add_item('Laptop', 1200)\n    # 1200 > 1000，应打9折\n    assert cart.calculate_total() == 1080.0\n\ndef test_mid_discount():\n    cart = Cart()\n    cart.add_item('Tablet', 600)\n    # 600 > 500，应打95折\n    assert cart.calculate_total() == 570.0\n\ndef test_member_discount():\n    cart = Cart()\n    cart.add_item('Item1', 100)\n    cart.add_item('Item2', 200)\n    cart.add_item('Item3', 300)\n    # 总价600 > 500，先打95折：600*0.95=570\n    # 购买3件以上，再打98折：570*0.98=558.6\n    assert cart.calculate_total() == 558.6\n\ndef test_combined_discount():\n    cart = Cart()\n    cart.add_item('Expensive1', 800)\n    cart.add_item('Expensive2', 400)\n    cart.add_item('Expensive3', 300)\n    # 总价1500 > 1000，先打9折：1500*0.9=1350\n    # 购买3件以上，再打98折：1350*0.98=1323\n    assert cart.calculate_total() == 1323.0\n\ndef test_clear_cart():\n    cart = Cart()\n    cart.add_item('Item', 100)\n    cart.clear()\n    assert cart.calculate_total() == 0\n\ndef test_rounding():\n    cart = Cart()\n    cart.add_item('Item1', 33.33, 3)\n    cart.add_item('Item2', 22.22, 2)\n    # 33.33*3 + 22.22*2 = 99.99 + 44.44 = 144.43\n    # 满500以下无折扣，购买3件以上无额外折扣（因为总价<500）\n    assert cart.calculate_total() == 144.43"}, "static_check_rules": [], "pass_condition": "pytest 通过率100%"}, "expected_defect": "开发者在重构时可能会错误地修改折扣计算逻辑的顺序或条件，例如：1) 将满减折扣和会员折扣的顺序颠倒；2) 错误地修改折扣阈值；3) 在提取逻辑时遗漏了某个折扣条件；4) 改变了折扣计算的组合方式。这些都会导致计算结果与原始逻辑不一致，破坏原有的业务契约。", "env_config": {"base_image": "python:3.10-slim", "dependencies": ["pytest==8.0.0"], "expose_port": [], "network_disabled": true}}
